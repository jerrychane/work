#### 2021年01月08日 周五 第02周

(1)数据结构与算法：队列任务-代码操作

#### 2021年01月11日 周一 第03周

(1) React 源码深度解析： memo 组件的更新 & completeUnitWork的整体流程和意义。

* 根据是否中断调用不同的方法；
* 判断是否有兄弟节点来执行不同的操作；
* 完成节点之后赋值 effect 链；

(2)数据结构与算法：任务队列代码实操

```js
export default (tasks, n) => {
    // 声明一个变量记录最终任务的顺序
    let q = ''
    // 任务分类
    let Q = {}
    tasks.forEach(item => {
        if (Q[item]) {
            Q[item]++
        } else {
            Q[item] = 1
        }
    });
    while (1) {
        let keys = Object.keys(Q)
        if (!keys[0]) {
            break
        }
        // n+1 为一组
        let tmp = []
        for (let i = 0; i <= n; i++) {
            let max = 0
            let key
            let pos
            // 从所有的任务中找到未处理数最大的优先安排
            keys.forEach((item, idx) => {
                if (Q[item] > max) {
                    max = Q[item]
                    key = item
                    pos = idx
                }
            })
            if (key) {
                tmp.push(key)
                keys.splice(pos, 1)
                Q[key]--
                if (Q[key] < 1) {
                    delete Q[key]
                }
            } else {
                break
            }
        }
        q += tmp.join('').padEnd(n + 1, '-')
    }
    // A--A--A-- 替换为 A--A--A
    q = q.replace(/-+$/g, '')
    return q.length
}
```

(3) 数据结构：排序链表 & 环形链表，重点是：如何手动创建一个链表的数据结构；知道链表如何排序；如何检测链表是闭环的。

排序链表：在O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例1：

```html
输入: 4->2->1->3
输出: 1->2->3->4
```

示例2：

```html
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

快速排序的本质：在遍历时选择一个基准元素，排序中的任何一个元素都可以作为基准元素，通常情况下选第一个就可以。把所有小于基准元素的元素，放在基准元素的左边；大于基准元素的元素，放在基准元素的右边；然后递归左边和右边的所有元素。

链表只会暴露一个头指针，所有的元素是不能直接访问到的，必须通过头指针不断地访问 next 对象，才能拿到具体的元素。设置两个指针p, q，都是指向头元素，p 指针左侧的元素是小于基准元素的，p 与 q 之间的元素是大于基准元素的。

#### 2021年01月12日 周二 第03周

(1) 高仿组件库:

> 参考网站：http://vikingship.xyz

* vikingship 是教学组件库，使用 React Hooks 和 typescript ；
* learning-typescript 为第二章 Typescript 入门源代码，只针对第二章；
* react-with-ts 为课程第三章，神奇的 React 源代码；

#### 2021年01月13日 周三 第03周

(1)数据结构与算法：链表的快速排序比堆排序使用的场景更多。

(2)数据结构与算法：环形链表-原理讲解

环形链表：给定一个链表，判断链表中是否有循环。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1` ，则在该链表中没有环。

示例1：

```
输入：head = [3,2,0,-4],pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

(3) 环形链表-代码实操

#### 2021年01月14日 周四 第03周

(1) 数据结构与算法：螺旋矩阵 & 旋转图像

给定一个包含 m x n 个元素的矩阵（m行，n列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例1：

```
输入：
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
输出：[1,2,3,6,9,8,7,4,5]
```

(2) 数据结构与算法：旋转图像

给定一个 n x n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例1：

```
给定 matrix = 
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
原地旋转输入矩阵，使其变为：
[
	[7,4,1],
	[8,5,2],
	[9,6,3]
]
```

示例2：

```
给定 matrix = 
[
 [5,1,9,11],
 [2,4,8,10],
 [13,3,6,7],
 [15,14,12,16]
]
原地旋转输入矩阵，使其变为：
[
	[15,13,2,5],
	[14,3,4,1],
	[12,6,8,9],
	[16,7,10,11]
]
```

#### 2021年01月15日 周五 第03周

(1)数据结构与算法：旋转图像-代码实操

```js
export default (arr) => {
    // 获取 n 的维度
    let vecor = arr.length;
    // 垂直翻转
    for (let i = 0, len = vecor / 2; i < len; i++) {
        for (let j = 0, tmp; j < vecor; j++) {
            tmp = arr[i][j];
            arr[i][j] = arr[vecor - i - 1][j];
            arr[vecor - i - 1][j] = tmp;
        }
    }
    // 对角线翻转
    for (let i = 0; i < vecor; i++) {
        for (let j = 0, tmp; j < i; j++) {
            let tmp = arr[i][j];
            arr[i][j] = arr[j][i];
            arr[j][i] = tmp;
        }
    }
    return arr;
};
```

(2)数据结构与算法：对称二叉树-原理讲解，二叉树是出现频率很高，难度最大的数据结构。二叉树的特性之一是一个节点只有两个子节点，左节点和右节点。

给定一个二叉树，检查它是否是镜像对称。例如，二叉树 `[1,2,2,3,4,4,3] ` 是对称的。

```
	    1
	  /	 \
   2 		2
 /  \   / \
3   4  4   3
```

但是下面这个 `[1,2,2,null,3,null,3] ` 则不是镜像对称的：

```
		1
	/		\
	2		2
	\ 	\
	3 	3
```

(3) 数据结构与算法：对称二叉树-代码实操

```js
// 构造二叉树数据结构
// 二叉树的节点
class Node {
    constructor(val) {
        this.val = val;
        this.left = this.right = undefined;
    }
}
// 声明一个二叉树
class Tree {
    constructor(data) {
        // 临时存储所有节点，方便寻找父子节点
        let nodeList = [];
        // 顶节点
        let root;
        for (let i = 0, len = data.length; i < len; i++) {
            let node = new Node(data[i]);
            nodeList.push(node);
            if (i > 0) {
                // 计算当前节点属于哪一层
                let n = Math.floor(Math.sqrt(i + 1));
                // 记录当前层的起始点
                let q = Math.pow(2, n) - 1;
                // 记录上一层的起始点
                let p = Math.pow(2, n - 1) - 1;
                // 找到当前节点的父节点
                let parent = nodeList[p + Math.floor((i - q) / 2)];
                // 将当前节点和上一层的父节点做关联
                if (parent.left) {
                    parent.right = node;
                } else {
                    parent.left = node;
                }
            }
        }
        root = nodeList.shift();
        nodeList.length = 0;
        return root;
    }
    // 判断是否对称的静态方法
    static isSymmetry(root) {
        if (!root) {
            return true;
        }
        let walk = (left, right) => {
            if (!left && !right) {
                return true;
            }
            if ((left && !right) || (!left && right) || left.val !== right.val) {
                return false;
            }
            return walk(left.left, right.right) && walk(left.right, right.left);
        };
        return walk(root.left, root.right);
    }
}

export default Tree;
export {
    Node
};
```

#### 2021年01月16日 周六 第03周

(1)数据结构与算法：验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：

* 节点的左子树只包含小于当前节点的数。
* 节点的右子树只包含大于当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

示例1：

```
输入：
 		2
 	/  \
 	1 	3
输出：true
```

(2)数据结构与算法：验证二叉搜索树-代码实操

```js
class Node {
    constructor(val) {
        this.val = val;
        this.left = this.right = undefined;
    }
}

class Tree {
    constructor(data) {
        let root = new Node(data.shift());
        //   遍历所有的数据，逐渐插入到当前这棵搜索树上
        data.forEach((item) => {
            this.insert(root, item);
        });
        return root;
    }
    insert(node, data) {
        if (node.val > data) {
            if (node.left === undefined) {
                node.left = new Node(data);
            } else {
                this.insert(node.left, data);
            }
        } else {
            if (node.right === undefined) {
                node.right = new Node(data);
            } else {
                this.insert(node.right, data);
            }
        }
    }
    static walk(root) {
        if (!root.left && !root.right) {
            return true;
        } else if (
            (root.left && root.val < root.left.val) ||
            (root.right && root.val > root.right.val)
        ) {
            return false;
        } else {
            return Tree.walk(root.left) && Tree.walk(root.right);
        }
    }
}

export default Tree;
export {
    Node
};
```

(3)数据结构与算法：堆排序-原理讲解，根据字符串出现频率排序（排序） & 超级丑数（查找）

堆更靠近二叉树，而非堆栈；应用场景：利用堆的数据结构去排序和查找。

基本概念：

* 堆必须是完全二叉树（n-1层是满二叉树，都有左右节点）；

* 任一节点的值是其子树所有节点的最大值或最小值。

例如：

```
		  	56(最大堆)
			 /   \
		 19     40
    / \     /
   18  9   3
```

```
		  	 5(最小堆)
			 /   \
		 16     30
    / \     /
   49  18  38
```

#### 2021年01月17日 周日 第03周

do nothing.

#### 2021年01月18日 周一 第04周

(1)数据结构与算法：堆排序-代码演示

```js
class Heap {
    constructor(data) {
        this.data = data;
    }
    sort() {
        let iArr = this.data;
        let n = iArr.length;
        if (n <= 1) {
            return iArr;
        } else {
            for (let i = Math.floor(n / 2); i >= 0; i--) {
                Heap.maxHeapify(iArr, i, n);
            }
            for (let j = 0; j < n; j++) {
                Heap.swap(iArr, 0, n - 1 - j);
                Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
            }
            return iArr;
        }
    }
    // 交换两个元素的方法
    static swap(arr, a, b) {
        if (a === b) {
            return "";
        }
        let c = arr[a];
        arr[a] = arr[b];
        arr[b] = c;
    }
    /**
     * 构建最大堆的过程
     * @param {*} Arr 数组
     * @param {*} i  哪个节点
     * @param {*} size 数组有效长度
     */
    static maxHeapify(Arr, i, size) {
        // 左节点（索引）
        let l = i * 2 + 1;
        // 右节点（索引）
        let r = i * 2 + 2;
        let largest = i;
        // 父节点i和左节点l作比较取最大值
        if (l <= size && Arr[l] > Arr[largest]) {
            largest = l;
        }
        // 右节点和最大值比较
        if (r <= size && Arr[r] > Arr[largest]) {
            largest = r;
        }
        if (largest !== i) {
            Heap.swap(Arr, i, largest);
            Heap.maxHeapify(Arr, largest, size);
        }
    }
}

export default Heap;
```

(2)数据结构与算法：堆排序-代码演示

根据字符出现频率排序，给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例1：

```
输入："tree"
输出："eert"
解释：'e' 出现两次，'r'和't'都只出现一次。因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

第一步：统计；第二步：排序；第三步：输出；

```js
class Heap {
    constructor(str) {
        let map = new Map();
        str.split("").forEach((item) => {
            if (map.has(item)) {
                map.set(item, map.get(item) + 1);
            } else {
                map.set(item, 1);
            }
        });
        this.map = map;
        this.data = Array.from(map.values());
    }
    sort() {
        let iArr = this.data;
        let n = iArr.length;
        if (n <= 1) {
            return iArr;
        } else {
            for (let i = Math.floor(n / 2); i >= 0; i--) {
                Heap.maxHeapify(iArr, i, n);
            }
            for (let j = 0; j < n; j++) {
                Heap.swap(iArr, 0, n - 1 - j);
                Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
            }
            return iArr;
        }
    }
    toString() {
        let arr = this.sort();
        let str = [];
        while (arr.length) {
            let top = arr.pop();
            for (let [k, v] of this.map) {
                if (v === top) {
                    str.push(k.repeat(v));
                    this.map.delete(k);
                    break;
                }
            }
        }
        return str.join("");
    }
    // 交换两个元素的方法
    static swap(arr, a, b) {
        if (a === b) {
            return "";
        }
        let c = arr[a];
        arr[a] = arr[b];
        arr[b] = c;
    }
    /**
     * 构建最大堆的过程
     * @param {*} Arr 数组
     * @param {*} i  哪个节点
     * @param {*} size 数组有效长度
     */
    static maxHeapify(Arr, i, size) {
        // 左节点（索引）
        let l = i * 2 + 1;
        // 右节点（索引）
        let r = i * 2 + 2;
        let largest = i;
        // 父节点i和左节点l作比较取最大值
        if (l <= size && Arr[l] > Arr[largest]) {
            largest = l;
        }
        // 右节点和最大值比较
        if (r <= size && Arr[r] > Arr[largest]) {
            largest = r;
        }
        if (largest !== i) {
            Heap.swap(Arr, i, largest);
            Heap.maxHeapify(Arr, largest, size);
        }
    }
}

export default Heap;
```

(3)数据结构与算法：超级丑数，丑数，质因数，质数。

编写一段程序来查找第 n 个超级丑数。超级丑数是指其所有质因数都是长度为 k 的质数列表 `primes` 中的正整数。

示例：

```
输入：n=12,primes=[2,7,13,19]
输出：32
解释：给定长度为 4 的质数列表 primes=[2,7,13,19],前12个超级丑数列表为：[1,2,4,7,8,13,14,16,19,26,28,32]。
```

解题思路：

* 求解任意整数的质因数
* 质因数是否在指定质因数范围内
* 是否达到指定个数 n

#### 2021年01月20日 周三 第04周

(1) 数据结构与算法: 超级丑数-代码演示(数组查找)

```js
class Ugly {
    constructor(n, primes) {
        this.n = n;
        this.primes = primes;
    }
    // 计算超级丑数
    getAll() {
        // 超级丑数列表
        let res = [1];
        let i = 2;
        let primes = this.primes;
        while (res.length < this.n) {
            let arr = Ugly.getPrimes(i);
            let k = 0;
            let l = arr.length;
            for (; k < l; k++) {
                if (!primes.find((item) => item === arr[k])) {
                    break;
                }
            }
            // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
            if (k === l) {
                if (l === 0) {
                    if (primes.find((item) => item === i)) {
                        res.push(i);
                    }
                } else {
                    res.push(i);
                }
            }
            i++;
        }
        return res[this.n - 1];
    }
    // 计算指定正整数n的质因数
    static getPrimes(n) {
        //
        let prime = (n) => {
            // 存储所有的质因数
            let arr = [];
            for (let i = 2; i < n / 2 + 1; i++) {
                if (n % i === 0 && !prime(i).length) {
                    arr.push(i);
                }
            }
            return arr;
        };
        return prime(n);
    }
}

export default Ugly;
```

(2) 数据结构与算法: 超级丑数-代码演示(堆查找)

```js
class Ugly {
    constructor(n, primes) {
        this.n = n;
        this.primes = new Heap(primes);
    }
    // 计算超级丑数
    getAll() {
        // 超级丑数列表
        let res = [1];
        let i = 2;
        let primes = this.primes;
        while (res.length < this.n) {
            let arr = Ugly.getPrimes(i);
            let k = 0;
            let l = arr.length;
            for (; k < l; k++) {
                if (!primes.find(arr[k])) {
                    break;
                }
            }
            // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
            if (k === l) {
                if (l === 0) {
                    if (primes.find(i)) {
                        res.push(i);
                    }
                } else {
                    res.push(i);
                }
            }
            i++;
        }
        return res[this.n - 1];
    }
    // 计算指定正整数n的质因数
    static getPrimes(n) {
        //
        let prime = (n) => {
            // 存储所有的质因数
            let arr = [];
            for (let i = 2; i < n / 2 + 1; i++) {
                if (n % i === 0 && !prime(i).length) {
                    arr.push(i);
                }
            }
            return arr;
        };
        return prime(n);
    }
}

class Heap {
    constructor(arr) {
        this.data = arr;
        this.max = arr.length;
        this.sort();
    }
    find(val, i = 0) {
        let arr = this.data;
        if (val > arr[i] || i > this.max) {
            return false;
        } else if (val === arr[i]) {
            return val;
        } else {
            return this.find(val, i * 2 + 1) || this.find(val, i * 2 + 2);
        }
    }
    sort() {
        let iArr = this.data;
        let n = iArr.length;
        if (n <= 1) {
            return iArr;
        } else {
            for (let i = Math.floor(n / 2); i >= 0; i--) {
                Heap.maxHeapify(iArr, i, n);
            }
            return iArr;
        }
    }
    // 交换两个元素的方法
    static swap(arr, a, b) {
        if (a === b) {
            return "";
        }
        let c = arr[a];
        arr[a] = arr[b];
        arr[b] = c;
    }
    /**
     * 构建最大堆的过程
     * @param {*} Arr 数组
     * @param {*} i  哪个节点
     * @param {*} size 数组有效长度
     */
    static maxHeapify(Arr, i, size) {
        // 左节点（索引）
        let l = i * 2 + 1;
        // 右节点（索引）
        let r = i * 2 + 2;
        let largest = i;
        // 父节点i和左节点l作比较取最大值
        if (l <= size && Arr[l] > Arr[largest]) {
            largest = l;
        }
        // 右节点和最大值比较
        if (r <= size && Arr[r] > Arr[largest]) {
            largest = r;
        }
        if (largest !== i) {
            Heap.swap(Arr, i, largest);
            Heap.maxHeapify(Arr, largest, size);
        }
    }
}
export default Ugly;
export {
    Heap
};
```

(3)进阶算法：贪心算法-买卖股票的最佳时机&柠檬水找零

(4进阶算法: 贪心算法（又称贪婪算法），是指在对**问题求解**时，总是做出在当前看来是最好的的选择。也就是说，不从整理最优上加以考虑，他所做出的是在某种意义上的**局部最优解**。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须是具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

**买卖股票的最佳时机 II:** 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1：

```
输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
随后，在第4天（股票价格=3）的时候买入，在第5天（股票价格=6）的时候卖出，这笔交易所能获得利润 = 6-3=3。
```

示例2：

```
输入：[1,2,3,4,5]
输出：4
解释：在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例3：

```
输入：[7,6,4,3,1]
输出：0
解释：在这种情况下，没有完成交易，所以最大利润为0。
```

贪心算法：

**问题：最大利润**

**策略1**：从最低点买入，在最高点卖出（追求单次利益）

**策略2**：从低点买入，只要可以赚钱就卖出；不断买卖（追求多次利益，单次利益不够）

**策略3**：从低点买入，到价格高点卖出，不断买卖（在保证单次利益的基础上，实现多次交易）

#### 2021年01月21日 周四 第04周

(1) 数据结构与算法：买卖股票最佳时机-代码实操

```js
export default (prices) => {
    // 用来保存利润
    let count = 0;
    for (let i = 0, len = prices.length; i < len; i++) {
        for (let j = i; j < len - 1; j++) {
            if (prices[j + 1] > prices[j]) {
                count += prices[j + 1] - prices[j];
                i = j;
            } else {
                i = j;
                break;
            }
        }
    }
    return count;
};
```

(2) 数据结构与算法：柠檬水找零-原理讲解，在柠檬水摊位上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你支付5美元、10美元或20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付5美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true，否则返回 false。

示例1：

```
输入：[5,5,5,10,20]
输出：true
解释：
前3位顾客那里，我们按顺序收取3张5美元的钞票。
第4位顾客那里，我们收取一张10美元的钞票，并返回5美元。
第5位顾客那里，我们找还一张10美元的钞票和一张5美元的钞票。
由于所有客户都得到了正确的找零，所以我们会输出 true。
```

问题：找零钱

策略1：给钱找零，不区分金额直到找到足够的零钱（追求单词找零）

策略2：给钱找零，优先给金额大的零钱，尽量把零钱放在手里（追求多次找零）

示例2：

```
输入：[5,5,10]
输出：true
```

示例3：

```
输入：[10,10]
输出：false
```

示例4：

```
输入：[5,5,10,10,20]
输出：false
```

(3)数据结构与算法：柠檬水找零-代码演示

```js
export default (input) => {
    // 表示自己的钱箱（用于存储零钱）
    let hand = [];
    // 判断是否有顾客还在
    while (input.length) {
        // 取出当前排在最前面顾客的钱
        let money = input.shift();
        // 这种情况不需要找零钱
        if (money === 5) {
            hand.push(money);
        } else {
            // 手里的零钱要降序排列，也就是说最大的面值的钱放在最前面
            hand.sort((a, b) => b - a);
            // 顾客的钱减去饮料的钱就是需要找给顾客的零钱
            let change = money - 5;
            for (let i = 0, len = hand.length; i < len; i++) {
                if (hand[i] <= change) {
                    change -= hand[i];
                    hand.splice(i, 1);
                    // 删除了元素，数组的长度发生了变化，要维持刚才的i不变
                    i--;
                }
                if (change === 0) {
                    break;
                }
            }
            // 没有足够的钱找给顾客
            if (change !== 0) {
                return false;
            } else {
                // 顾客的钱存起来
                hand.push(money);
            }
        }
    }
    return true;
};
```

#### 2021年01月22日 周五 第04周

(1) 数据结构与算法：进阶算法-动态规划之不同路径II 和 K 站中转内最便宜的航班

动态规划三个重要概念：动态转移方程、最优子结构、边界

不同路径II：一个机器人位于一个 m x n 网格的左上角（起点在下图中标记的 Start）。机器人每次只能向下或向右移动一步。机器人试图到达网格的右下角（在下图中标记为 Finish）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

| Start |      |      |      |      |      |        |
| :---: | ---- | ---- | ---- | ---- | ---- | :----: |
|       |      |      |      |      |      |        |
|       |      |      |      |      |      | Finish |

网格中的障碍物和空位置分别用1和0来表示。

示例1：

```
输入：
[
 [0,0,0],
 [0,1,0],
 [0,0,0]
]
输出：2
解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有2条不同的路径：
1.向右 -> 向右 -> 向下 -> 向下
2.向下 -> 向下 -> 向右 -> 向右
```

mxn：m行n列的状态方程是 F(mxn) = F(m-1xn) + F(mxn-1)

(2)不同路径II-代码实操：

```js
export default (arr, m, n) => {
    let dp = (m, n) => {
        // m=2,n=2 的边界
        if (m === 2 && n === 2) {
            return arr[1][1] || arr[1][0] + arr[0][1] === 2 ?
                0 :
                arr[1][0] === 1 || arr[0][1] === 1 ?
                1 :
                2;
        } else if (m < 2 || n < 2) {
            if (m < 2) {
                // 单行有1就返回0，没有1返回1
                return arr[m - 1].includes(1) ? 0 : 1;
            } else {
                // 单列不能有障碍物(1)有它返回0，没有1返回1
                for (let i = 0; i < m; i++) {
                    if (arr[i][0] === 1) {
                        return 0;
                    }
                }
                return 1;
            }
        } else {
            return dp(m - 1, n) + dp(m, n - 1);
        }
    };
    return dp(m, n);
};
```

(3) K站中转内最便宜的航班：有n个城市通过m个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和 目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。

如果没有这样的路线，则输出 -1。

示例1：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=1
输出：200
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

示例2：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=0
输出：500
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

动态转移方程：F(src, dst, k) = Min(F(src, dst-1, k-1) + F(dst-1, dst, 1))

(4) k站中转站-代码实操

```js
export default (src, dst, k) => {
    // 对n个城市m个航班做飞行说明
    let fights = [
        [0, 1, 100],
        [1, 2, 100],
        [0, 2, 500],
    ];
    let cheap = (src, dst, k) => {
        // 找到 dst 的前一站
        let prev = fights.filter((item) => item[1] === dst);
        let min = Math.min.apply(
            null,
            prev.map((item) => {
                // 从 dst 往前找，找到了起始城市
                if (item[0] === src && k > -1) {
                    return item[2];
                } else if (k === 0 && item[0] !== src) {
                    return Number.MAX_SAFE_INTEGER;
                } else {
                    return item[2] + cheap(src, item[0], k - 1);
                }
            })
        );
        return min;
    };
    return cheap(src, dst, k) || -1;
};
```

(5) 课程总结：

基础算法：

| 常见类型：字符串、数组、正则 |
| ---------------------------- |
| 常见题型：查重、排序、递归   |
| 知识点：基础API、常用技巧    |

数据结构与算法：

| 常见结构：栈、队列、链表、矩阵、二叉树、堆 |
| ------------------------------------------ |
| 常见题型：结构实现、查找、排序、拓展应用   |
| 知识点：原理、实现、实战思想               |

(6) 前端人的危机如何破解选

选择和被选择都是一种能力。可以选择是一种资本，可以被选择是一种资历，无论是哪种都可以成就一番事业。不然危机会大一些、遗憾也会随之而来。破除危机：积累可以选择的资本 or 增加被选择的资历。

会工作 & 会学习：入门级 - 如何学习？如何面试？如何提升？风险最高。

入门级：

如何学习？人群：学生、转行、自学；目标：学习基础知识；途径：网络博客、视频课程、培训班；方法：临摹；自测：是不是能够独立解决问题；心态：脚踏实地、切莫投机取巧。

如何面试？目标：工作机会；准备：基础知识+实战经验；技巧：基础+能力+潜力；自测：刷题+面经+技术分析。基础知识好不等于要懂所有的知识；每个人都有自己的知识盲区。

如何提升？目标：提升解决问题的能力；方法：多看、多听、多做、多思考，不放过任何一个机会；忌讳：自负、多问题、懒散；自测：是否能独立解决问题。

中高级：如何学习？如何成长？如何晋升？

如何学习？背景：学的很累；原则：先少后多、先精后广；方法：平衡学习、工作、生活的时间，多利用社区的力量；

如何成长？定义：技术、做事；方法：自驱动、敢于挑战、承担责任；自测：技术架构、独立做事、彼此成就。

如何晋升？目标：加薪、晋级；方法：少说、多做、任劳任怨、有效沟通、拒绝平庸、全面发展；心态：先付出再回报、个人服从集体、学会定位和补位、足够耐心。

(7) TS+React打造组件库：

(8) WebRTC学习：

特点：Google开源、跨平台、用于浏览器、实时传输、音视频引擎；

应用领域：音视频会议在线教育、照相机、音乐播放器、共享远程桌面、录制、即时通讯工具、P2P网络加速、文件传输工具、游戏、实时人脸识别；

#### 2021年01月23日 周六 04周

(1) WebRTC学习：学习收获，WebRTC API 的使用；WebRTC 工作原理；信令服务器的设计与搭建；实现1:1实时互动直播系统。

(2) WebRTC 入门与实战：WebRTC 介绍

WebRTC 概述：

* 音视频处理+即时通讯的开源库；
* 2010年 Google 将其开源；
* 它是一个非常优秀的多媒体框架，跨平台；

WebRTC应用：

* 音视频实时互动；游戏、即时通讯、文件传输等等；它是一个百宝箱，传输、音视频处理（回音消除、降噪等）

能学到什么：

* 音视频设备访问与管理；音视频数据的采集；数据的传输与实时互动；WebRTC 的工作机制；

(3) TS+React组件库：安装和初试TypeScript

```bash
# 全局安装
npm install -g typescript@3.7.2
# 查看版本号
tsc -v 
```

（4）TS+React组件库：基础类型， undefined 和 null 是所有类型的子类型

（5）TS+React组件库：any 类型和联合类型，尽可能慎用，

```typescript
//any 类
let notSure: any = 4
notSure = 'maybe it is a string'
notSure = true
notSure.myName
notSure.getName()
```

```typescript
// union 类型
let numberOrString: number | string = 234
numberOrString = 'abc'
```

（6）TS+React组件库：Array 和 Tuple(元组)

```typescript
// Array
let arrayOfNumber: number[] = [1, 2, 3, 4]
arrayOfNumber.push(5)
// Tuple 元组是限定了数据类型的一种数组，必须所有类型都有
let user: [string, number] = ['viking', 1]
```

（7）TS+React组件库：Interface接口，定义对象的类型 

 - 对对象的形状（shape） 进行描述
 - 对类（class） 进行抽象
 - Duck Typing（鸭子类型 ）

```typescript
// interface
interface Person {
    readonly id: number;
    name: string;
    age?: number;
}
let viking: Person = {
    id: 1234,
    name: 'viking',
    age: 20
}
```

可选属性 ？加在属性后面；可读属性，readonly 加在属性前面，readonly 用在对象属性上，而 const  用在变量上；

（8）TS+React组件库：函数和类型判断

```typescript
// 函数声明
function add(x: number, y: number, z?: number): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
let result = add(2, 3, 5)
```

可选参数后不能加确定的参数，否则会报错；也可以添加默认参数。

```typescript
// 函数表达式
function add(x: number, y: number, z: number = 10): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
let result = add(2, 3)
```

```typescript
// 函数表达式,类型推断
const add = function (x: number, y: number, z: number = 10): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
const add2: (x: number, y: number, z?: number) => number = add 
```

typescript 可以在没有明确指定类型时，推断出要使用的类型。

#### 2021年01月24日 周日 04周

(1) WebRTC学习：WebRTC 原理与架构， 网页端和浏览器端。其中浏览器端有包括音频引擎（音频采集和渲染）、视频引擎（视频采集）、传输层（数据的输入输出）。

(2)  WebRTC学习： WebRTC的目录结构

| 编号 | 目录            | 功能                                                   |
| ---- | --------------- | ------------------------------------------------------ |
| 01   | api             | webrtc接口层，浏览器都是通过该接口调用webrtc           |
| 02   | call            | 数据流的管理层，call代表同一个端点的所有数据的流入流出 |
| 03   | video           | 与视频相关的逻辑                                       |
| 04   | audio           | 与音频相关的逻辑                                       |
| 05   | common_audio    | 音频算法相关                                           |
| 06   | common_video    | 视频算法相关                                           |
| 07   | media           | 与多媒体相关的逻辑处理，如编解码的逻辑处理             |
| 08   | logging         | 日志相关                                               |
| 09   | module          | 最重要的目录，子模块                                   |
| 10   | pc              | peer connection, 连接相关的逻辑层                       |
| 11   | p2p             | 端对端相关代码，stun，turn                             |
| 12   | rtc_base        | 基础代码，如线程、锁相关的统一接口代码                 |
| 13   | rtc_tool        | 音视频分析相关的工具代码                               |
| 14   | tool_webrtc     | webrtc测试相关的工具代码，如网络模拟器                 |
| 15   | system_warppers | 与具体操作系统相关的代码。如cpu特性，原子操作等        |
| 16   | stats           | 存放各种数据统计相关的类                               |
| 17   | sdk             | 存放android和ios层代码。如视频的采集、渲染等。         |

webrtc modules 目录

| 编号 | 目录                     | 功能                                 |
| ---- | ------------------------ | ------------------------------------ |
| 01   | audio_coding             | 音频编解码相关代码                   |
| 02   | audio_device             | 音频采集与音频播放相关代码           |
| 03   | audio_mixer              | 混音相关代码                         |
| 04   | audio_processing         | 音频前后处理的相关代码               |
| 05   | bitrate_controller       | 码率控制相关的代码                   |
| 06   | congestion_controller    | 流控制相关的代码                     |
| 07   | desktop_capture          | 桌面采集相关的代码                   |
| 08   | pacing                   | 码率探测及平滑处理相关的代码         |
| 09   | remote_bitrate_estimator | 远端码率估算相关的代码               |
| 10   | rtp_rtcp                 | rtp/rtcp协议相关的代码               |
| 11   | video_capture            | 视频采集相关的代码                   |
| 12   | video_coding             | 视频编解码相关的代码                 |
| 13   | video_processing         | 视频前后处理相关的代码，例如人脸识别 |

(4)TS+React组件库：类 Class，第一部分

* 类(Class) : 定义了一切事物的抽象特点
* 对象（Object）: 类的实例
* 面向对象（OOP）三大特性：封装、继承、多态

```bash
# locally in your project
npm i -D ts-node
npm i -D typescript
# or globally with typescript
npm i -g ts-node
npm i -g typescript

# 在控制台
ts-node class.ts
```

(5)TS+React组件库：类 Class，第二部分，修饰符 public（公共属性） / private（私有属性, 子类无法访问） / protected（受保护的属性，子类可以访问该属性）; readonly （只读不可写属性）

 static 表示静态属性或方法，无需实例化即可访问，与实例也无关系。

(6)TS+React组件库：类和接口

```typescript
interface Radio {
    switchRadio(): void;
}
interface Battery {
    checkBatteryStatus();
}
interface RadioWithBattery extends Radio {
    checkBatteryStatus();
}
class Car implements Radio {
    switchRadio() {

    }
}
class Cellphone implements RadioWithBattery {
    switchRadio() {

    }
    checkBatteryStatus() {

    }
}
```

(7)TS+React组件库：枚举（Enum）

```typescript
enum Direction {
    Up = 10,
    Down,
    Left,
    Right,
}
console.log(Direction.Up)
console.log(Direction.Down)
console.log(Direction.Left)
console.log(Direction.Right)
console.log(Direction[10])
```

```typescript
enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
}
const value = 'UP'
if (value === Direction.Up) {
    console.log('go up!')
}
```

使用常量枚举可以提升性能。

```typescript
const enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
}
const value = 'UP'
if (value === Direction.Up) {
    console.log('go up!')
}
```

(7)TS+React组件库：泛型，第一部分。泛型是 TS 中最难的部分。

```typescript
function echo<T>(arg: T): T {
    return arg
}
// const str: string = 'str'
const result = echo(123)

function swap<T, U>(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]]
}
// const result2:[number,string]
const result2 = swap(['string', 123]) 
```

泛型就像一个占位符或者是一个变量，在使用的时候，可以把定义好的类型，像参数一样传入，然后它可以原封不变的输出。

#### 2021年01月25日 周一 05周

(1) WebRTC学习：WebRTC运行机制，Track(轨) & MediaStream（流）

WebRTC重要的类：

* MediaStream
* RTCPeerConnection（最重要的类）
* RTCDataChannel（非音视频的类）

(2)TS+React组件库：泛型-约束泛型

```typescript
// 约束泛型-方案一,返回结果只能是数组
function echoWithArr<T>(arg: T[]): T[] {
    console.log(arg.length)
    return arg
}
const arrs = echoWithArr([1, 2, 3])
// 约束泛型-方案二,通过 extends 和 interface 设置约束条件
interface IWithLength {
    length: number;
}
function echoWithLength<T extends IWithLength>(arg: T): T {
    console.log(arg.length)
    return arg
}
const str = echoWithLength('str')
const obj = echoWithLength({ length: 10, width: 10 })
const arr2 = echoWithLength([1, 2, 3])
```

(3)TS+React组件库：泛型-类和接口

```typescript
// 类使用泛型约束
class Queue<T> {
    private data = []
    push(item: T) {
        return this.data.push(item)
    }
    pop(): T {
        return this.data.shift()
    }
}
const queque = new Queue<number>()
queque.push(1)
console.log(queque.pop().toFixed())

const queque2 = new Queue<string>()
queque2.push('str')
console.log(queque2.pop().length)
```

```typescript
// 接口添加泛型
interface KeyPair<T, U> {
    key: T;
    value: U;
}
let kp1: KeyPair<number, string> = { key: 123, value: 'str' }
let kp2: KeyPair<string, number> = { key: 'test', value: 123 }

let arr: number[] = [1, 2, 3]
let arrTwo: Array<number> = [1, 2, 3]

// inerface 描述一个函数的type
interface IPlus<T> {
    (a: T, b: T): T
}
function plus(a: number, b: number): number {
    return a + b;
}
function connect(a: string, b: string) {
    return a + b;
}
const a: IPlus<number> = plus
const b: IPlus<string> = connect
```

(4)TS+React组件库：类型别名和类型断言

类型别名：

```typescript
// type aliases
type PlusType = (x: number, y: number) => number
function sum(x: number, y: number): number {
    return x + y
}
const sum2: PlusType = sum
// 联合类型下的类型别名
type NameResolver = () => string
type NameOrResolver = string | NameResolver
function getName(n: NameOrResolver): string {
    if (typeof n === 'string') {
        return n
    } else {
        return n()
    }
}
```

类型断言：

```typescript
// type assertion
function getLength(input: string | number): number {
    const str = input as String
    if (str.length) {
        return str.length
    } else {
        const number = input as Number
        return number.toString().length
    }
}
// 更简单的写法
// type assertion
function getLength(input: string | number): number {
    if ((<string>input).length) {
        return (<string>input).length
    } else {
        return input.toString().length
    }
}
```

(5)TS+React组件库：声明文件，声明文件通常是d.ts后缀的文件，例如jQquery.d.ts

```bash
npm install --save @types/jquery
```

#### 2021年01月26日 周二 05周

(1) WebRTC学习：Web服务器工作原理

Web服务器选型：

* Nodejs
* Nginx
* Apache

两个V8引擎：Chrome & Node

(2) TS+React打造个人组件库：React 简介和基础知识，props&state，组件的生命周期，状态提升和单向数据流。

(3) TS+React打造个人组件库：配置 React 开发环境

* 官方脚手架工具-create-react-app

```bash
npx create-react-app ts-with-react --template typescript
```

npx 是什么？

* 避免安装全局模块
* 调用项目内部安装的模块

#### 2021年01月27日 周三 05周

(1) WebRTC学习：Nodejs环境搭建

Nodejs 的安装方式：1. 二进制库安装；2. 源码安装；

二进制库安装步骤：

* apt/brew/yum install nodejs
* apt/brew/yum install npm

```bash
apt-cache search nodejs
apt install nodejs
apt install npm
```

源码安装步骤：

* 下载 Nodejs 源码
* 生成 Makefile
* `make -j 4 && sudo make install`

```bash
wget -c https://npm.taobao.org/mirrors/node/v14.15.4/node-v14.15.4.tar.gz
# 解压
tar -zvxf node-v14.15.4.tar.gz
cd node-v14.15.4
ls configure
./configure --prefix=/usr/local/nodejs
```

（2）TS+React 打造组件库：第一个组件 - ts为组件助力

```typescript
import React from 'react'

interface IHelloProps {
    message?: string;
}
// type React.FC<P = {}> = React.FunctionComponent<P>
const Hello: React.FC<IHelloProps> = (props) => {
    return <h2>{props.message}</h2>
}
Hello.defaultProps = {
    message: 'Hello World'
}
export default Hello
```

（3）TS+React 打造组件库：什么是和为什么要用 React Hook，React 16.8 带来的新特性，即将替代 class 组件的写法

没有破坏性改动：1. 完全可选；2. 百分百向后兼容；3. 没有计划从 React 移除 class; 

为什么用 hook：组件很难复用状态逻辑； 复杂组件难以理解，尤其是生命周期函数；React 组件一直是函数，使用 Hook 完全拥抱函数；

（4）TS+React 打造组件库：在函数组件使用 state-useState Hook

Hook 是什么？Hook 是一个函数，它可以钩住 React 组件的特性; 什么时候会使用 useState Hook ? 

```tsx
import React, { useState } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

（5）TS+React 打造组件库：useEffect 第一部分-初出茅庐

* 无需清除的 Effect，例如发送网络请求，手动变更DOM，记录日志；
* 需要清除的 Effect

useEffect 在第一次渲染和每次渲染时都会执行。

代码时间：使用 useEffect 完成 DOM 的更新

```tsx
import React, { useState, useEffect } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    useEffect(() => {
        document.title = `点击了 ${like} 次`
    })
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

（6）TS+React 打造组件库：useEffect 第二部分-有始有终

* 需要清除的Effect
* 代码时间：使用 useEffect 完成一个鼠标跟踪器

```typescript
import React, { useState, useEffect } from 'react'

const MouseTracker: React.FC = () => {
    const [postions, setPositions] = useState({ x: 0, y: 0 })
    useEffect(() => {
        console.log('add effect', postions.x)
        const updateMouse = (e: MouseEvent) => {
            console.log('inner')
            setPositions({ x: e.clientX, y: e.clientY })
        }
        document.addEventListener('click', updateMouse)
        return () => {
            console.log('move effect', postions.x)
            document.removeEventListener('click', updateMouse)
        }
    })
    console.log('before render', postions.x)
    return (
        <p>X: {postions.x} ,Y:{postions.y} </p>
    )
}

export default MouseTracker
```

#### 2021年01月28日 周四 05周

(1) WebRTC学习：最简单的 http 服务

* require 引入 http 模块
* 创建 http 服务
* 指定监听端口

```javascript
// 创建 http.js
"use strict";
var http = require("http");
var app = http
    .createServer(function(req, res) {
        res.writeHead(200, {
            "Content-Type": "text/plain"
        });
        res.end("Hello World\n");
    })
    .listen(8080, "127.0.0.1");
```

```bash
# 运行 http.js 的三种方式
# 方式一，断开服务后，所有服务终止
node http.js
# 方式二，一直保持，但日志输出有问题
nohub node http.js & 
# 方式三，通过 forever,在后台启动或停止程序
forever start http.js
forever stop http.js
```

```bash
npm install forever -g 
```

#### 2021年01月29日 周五 05周

(1) WebRTC学习：创建 https 服务

为什么要使用HTTS服务？ 个人隐私及安全问题；https 是未来的趋势；HTTPS = HTTP + TLS/SSL

Nodejs 搭建 HTTPS 服务？ 生成 HTTPS 证书；引入 HTTPS 模块；指定证书位置，并创建 HTTPS 服务

```javascript
"use strict";
var https = require("https");
var fs = require("fs");
var options = {
    // 证书的地址
    key: fs.readFileSync("./....xxx.key"),
    cert: fs.readFileSync("./....xxx.pem"),
};
var app = https
    .createServer(options, function(req, res) {
        res.writeHead(200, {
            "Content-Type": "text/plain"
        });
        res.end("HTTPS:Hello World!\n");
    })
    .listen(443, "0,0,0,0");
```

（2）TS+React 打造组件库：useEffect 第三部分-控制运行

```typescript
import React, { useState, useEffect } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    useEffect(() => {
        console.log('document title effect is runnning')
        document.title = `点击了 ${like} 次`
    }, [like, on])
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

(3)TS+React 打造组件库：自定义 Hook-重构 MouseTracker，将组件逻辑抽取到可重用的函数中; 自定义 hooks 函数必须使用 `use` 开头

```tsx
import React, { useState, useEffect } from 'react'
const useMousePositon = () => {
    const [positions, setPositions] = useState({ x: 0, y: 0 })
    useEffect(() => {
        console.log('add effect', positions.x)
        const updateMouse = (e: MouseEvent) => {
            setPositions({ x: e.clientX, y: e.clientY })
        }
        document.addEventListener('mousemove', updateMouse)
        return () => {
            console.log('move effect', positions.x)
            document.removeEventListener('mousemove', updateMouse)
        }
    }, [])
    return positions
}
export default useMousePositon
```

(4)TS+React 打造组件库：自定义 Hook 第二部分-HOC的劣势

* 高阶组件就是一个函数，接受一个组件作为参数，返回一个新的组件。

#### 2021年01月31日 周日 05周

(1)WebRTC学习：真正的Web服务器，既支持http又支持https

* 引入express模块
* 引入server-index模块
* 指定发布目录

```bash
npm i express@4.16.4 serve-index@1.9.1 --save
```

(2)TS+React 打造组件库：自定义hook第三部分-正确的方式完成 URLLoader

```typescript
import { useState, useEffect } from 'react'
import axios from 'axios'

const useURLLoader = (url: string, deps: any[] = []) => {
    const [data, setData] = useState<any>(null)
    const [loading, setLoading] = useState(false)
    useEffect(() => {
        setLoading(true)
        axios.get(url).then(result => {
            setData(result.data)
            setLoading(false)
        })
    }, deps)
    return [data, loading]
}
export default useURLLoader
```

 可以将逻辑上重复的代码提取到一个函数中，像调用一个函数一样调用 hooks，使用hooks返回结果，做我们想做的。

(3)TS+React 打造组件库：useRef - state遇到的难题

在任意一次渲染过程中，props 和 state 始终是保持不变的，如果 props 和 state 在渲染过程中是相互独立的，那么使用到它们的任何值，也都是独立的。useRef 是让不同的渲染之间产生联系的 hook 函数。

(4)TS+React 打造组件库：useRef - 多次渲染之间的纽带

修改 ref 的值，组件不会重新渲染；

#### 2021年02月01日 周一 06周

(1)WebRTC学习：JavaScript 调试方法

```javascript
// google demo
https: //appr.tc
```

(2)TS+React 打造组件库：useContext-解决多层传递属性的灵丹妙药

context 提供了一种在组件间共享属性的方式，而不必通过组件树的形式，通过每个层级显示的传递 props。context 的设计是为了共享对于组件树而言是全局的数据。

```typescript
// App.tsx
export const ThemeContext = React.createContext(themes.light)
<ThemeContext.Provider value={themes.dark}></ThemeContext.Provider>

// LikeButton.tsx
import React, { useState, useEffect, useRef, useContext } from 'react'
const theme = useContext(ThemeContext)
    console.log(theme)
    const style = {
        background: theme.background,
        color: theme.color
    }
```

#### 2021年02月03日 周三 06周

(1) WebRTC学习：变量与基本运算

基础知识：变量与类型、for循环、基本运算、函数、if/else、日志打印

**变量与类型**

|          | javascript          | C语言                    |
| -------- | ------------------- | ------------------------ |
| 定义变量 | `var a;` ; `let a;` | `int a;` |
| 布尔     | `true` or `false` | `1` or `0` |
| 字符串   | `'hello world'` | `char str="hello world"` |
| 数组     | `[1,5.1,'  hw']` | `Int arr[]= {1,5,6}` |
| 空       | `null` , `undefined` | `NULL` , `0` |

**基本运算**

|          | javascript      | C语言           |
| -------- | --------------- | --------------- |
| 算数运算 | `+, -, *, / ,%` | `+, -, *, / ,%` |
| 比较运算 | `>,<,!=,==,===` | `>,<,!=,==` |
| 逻辑运算 | `&&,||,!` | `&&,||,!` |

#### 2021年02月04日 周四 06周

(1) WebRTC学习：判断循环与函数

|                  | javascript                               | C语言              |
| ---------------- | ---------------------------------------- | ------------------ |
| `if ... else` | `if (){} else if(){} else{}` | 同 javascript 一样 |
| `switch ...case` | `switch case` | 同 javascript 一样 |
| `for` | `for(...){}` | 同 javascript 一样 |
| `for ...in` | `for(var i in arr){console.log(arr[i])}` | 无                 |
| `while` | `while(){}` | 同 javascript 一样 |

**函数**

|          | javascript                          | C语言                          |
| -------- | ----------------------------------- | ------------------------------ |
| 函数定义 | `function func(...){...return ret}` | `int func(...){...return ret}` |
| 箭头函数 | `()=>{...}` | 无                             |

(2)TS+React 打造组件库：hook 规则和其他 hook

* 只在最顶层使用 hook
* 只在React函数中调用 hook

其他 hook : useReducer, useCallback

(3)TS+React 打造组件库：组件库起航-需求分析

完成一个组件库需要考虑的问题？

* 代码结构

* 样式解决方案

* 组件需求分析和编码

* 组件测试用例分析和编码

* 代码打包输出和发布

* CI/CD，文档生成等等

初始化组件项目

  

```bash
npx create-react-app jerrychaneui --template typescript
```

####  2021年02月05日 周五 06周

 (1)TS+React 打造组件库：文件结构和代码规范

一种是按照功能和路由；一种是按照文件类型；尽可能简单，本项目使用的文件结构如下

```
jerrychaneui/
	README.md
	node_modules
	package.json
	tsconfig.json
	src/
		components/
			Button/
				button.tsx
				button.test.tsx
				style.scss
    styles/
    	...
    index.tsx
```

代码规范: 2.0.4 以上的版本，不需要特殊配置，默认支持 `typescript` 语法检查，需安装 `eslint` 插件。

(2)TS+React 打造组件库：样式解决方案分析

* Inline CSS(性能最好)

```jsx
const divStyle = {
  color:'blue',
  backgroundImg:'url('+imgUrl+')',
}
function HelloComponent(){
  return <div style={style}>Hello</div>
}
```

* CSS in JS

* Style Component

* Sass / Less(本项目推荐)

样式文件系统结构：

```
styles/
	_variables.scss(各种变量以及可配置设置)
	_mixins.scss(全局 mixins)
	_functions.scss(全局 functions)
components/
	Button/
		style.scss(单组织文件的样式)
		...
```

(3) WebRTC学习：WebRTC获取音视频设备

API: enumerateDevices()

**基本格式**

```javascript
var ePromise = navigator.mediaDevices.enumerateDevices();
```

返回值是一个 Promise

**MediaDevicesInfo**

MediaDevicesInfo 中存放了许多音视频相关的信息；

| 属性     | 说明                                      |
| -------- | ----------------------------------------- |
| deviceID | 设备ID                                    |
| label    | 设备的名字                                |
| kind     | 设备的种类                                |
| groupID  | 两个设备GroupID相同，说明是同一个物理设备 |

**JavaScript 中的 Promise**

(4) WebRTC学习：在页面中显示获取到的设备

```javascript
// js/client.js
"use strict";
var audioSource = document.querySelector("select#audioSource");
var audioOutput = document.querySelector("select#audioOutput");
var videoSource = document.querySelector("select#videoSource");

if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
    console.log("enumerateDevices is not supported!");
} else {
    navigator.mediaDevices.enumerateDevices().then(gotDevice).catch(handleError);
}

function gotDevice(deviceInfos) {
    deviceInfos.forEach((deviceInfo) => {
        var option = document.createElement("option");
        option.text = deviceInfo.label;
        option.value = deviceInfo.deviceId;
        if (deviceInfo.kind === "audioinput") {
            audioSource.appendChild(option);
        } else if (deviceInfo.kind === "audiooutput") {
            audioOutput.appendChild(option);
        } else if (deviceInfo.kind === "videoinput") {
            videoSource.appendChild(option);
        }
    });
}

function handleError(error) {
    console.log(error.name + " : " + error.message);
}
```

#### 2021年02月07日 周日 06周

(1) WebRTC学习：WebRTC 音视频数据采集

基本格式：

```javascript
var promise = navigator.mediaDevices.getUserMedia(constraints)
```

MediaStreamConstrains:

```javascript
dictionary MediaStreamConstraints {
    (boolean or MediaTrackConstraints) video = false;
    (boolean or MediaTrackConstraints) audio = false;
}
```

```javascript
// js/client
"use strict";
var videoplay = document.querySelector("video#player");

function gotMediaStream(stream) {
    videoplay.srcObject = stream;
}

function handleError(error) {
    console.log("getUserMedia error:", error);
}

if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    console.log("getUserMedia is not supported");
} else {
    var constraints = {
        video: true,
        audeo: true,
    };
    navigator.mediaDevices
        .getUserMedia(constraints)
        .then(gotMediaStream)
        .catch(handleError);
}
```

(2) WebRTC学习：浏览器适配方法 WebRTC_API 适配

getUserMedia 适配：

* W3C 规范中：getUserMedia
* Chrome: webkitGetUserMedia
* Firefox: mozGetUserMedia

自己实现：

```javascript
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
```

使用 Google 开源库 adapter.js, 适配不同浏览器的 API

```
https://webrtc.github.io/adapter/adapter-latest.js
```

(3)TS+React 打造组件库：添加自己的色彩体系

创建自己组件库的色彩体系

* 系统色板 - 基础色板 + 中性色板
* 产品色板 - 品牌色 + 功能色板

Bootstrap 的色彩体系

* #0275d8 (蓝色)、#5cb85c(绿色)、#5bc0de(浅蓝)、#f0ad4e(橙色)、#d9534f(红色)、#292b2c(黑色)、#f7f7f7(白色)

我们组件库的色彩体系

* #0d6efd (蓝色)、#6c757d(黑色)、#52c41a(绿色)、#fadb14(橙色)、#dc3545(红色)、#17a2b8(黑色)

```shell
npm i node-sass --save
```

(4)TS+React 打造组件库：添加字体变量解决方案

组件库样式变量分类：1-基础色彩系统；2-字体系统；3-表单；4-按钮；5-边框和阴影；6-可配置开关

#### 2021年02月08日 周一 07周

(1) WebRTC学习：安全管理-获取音视频设备的访问权限

```javascript
"use strict";
var videoplay = document.querySelector("video#player");
let audioSource = document.querySelector("select#audioSource");
let audioOutput = document.querySelector("select#audioOutput");
let videoSource = document.querySelector("select#videoSource");

function gotDevices(deviceInfos) {
    deviceInfos.forEach((deviceInfo) => {
        let option = document.createElement("option");
        option.text = deviceInfo.label;
        option.value = deviceInfo.deviceId;
        if (deviceInfo.kind === "audioinput") {
            audioSource.appendChild(option);
        } else if (deviceInfo.kind === "audiooutput") {
            audioOutput.appendChild(option);
        } else if (deviceInfo.kind === "videoinput") {
            videoSource.appendChild(option);
        }
    });
}

function gotMediaStream(stream) {
    videoplay.srcObject = stream;
    return navigator.mediaDevices.enumerateDevices();
}

function handleError(error) {
    console.log("getUserMedia error:", error);
}

if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    console.log("getUserMedia is not supported");
} else {
    var constraints = {
        video: true,
        audio: true,
    };
    navigator.mediaDevices
        .getUserMedia(constraints)
        .then(gotMediaStream)
        .then(gotDevices)
        .catch(handleError);
}
```

(2)TS+React 打造组件库：初次亮相-添加normalize.css

```
https://github.com/necolas/normalize.css
```

#### 2021年02月09日 周二 07周

(1) WebRTC学习：视频参数调整-视频约束，WebRTC 音视频采集约束

* width / height / aspectRatio(比例) / frameRate(帧率) 
* facingMode(user: 前置摄像头；environment: 后置摄像头；left: 前置左摄像头；right: 前置右摄像头)
* resizeMode: 画面是否需要裁剪

#### 2021年02月10日 周三 07周

(1)WebRTC学习：视频参数调整-视频约束，WebRTC 音视频采集约束

```javascript
var constraints = {
    video: {
        width: {
            min: 480,
            max: 640
        },
        height: {
            min: 240,
            max: 320
        },
        frameRate: {
            min: 15,
            max: 30
        },
        facingMode: "environment",
    },
    audio: false,
};
```

(2)WebRTC学习：音频参数调整-音频约束

* volume(音量):0-1.0
* sampleRate(采样率)：48000, 32000, 8000
* sampleSize(采样大小)：16位即2字节
* echoCancellation(回音)：true || fasle
* autoGainControl(自动增益): true || fasle
* noiseSuppression(降噪): true || fasle
* latency(延迟大小):200ms以内是最好的
* channelCount(单双声道)
* deviceID、groupID

#### 2021年02月12日 周五 07周

do nothing

#### 2021年02月14日 周日 07周

do nothing

#### 2021年02月15日 周一 08周

(1)WebRTC学习：视频特效

* CSS filter, -webkit-filter/filter
* 如何将 video 与 filter 关联
* OpenGL/Metal/ ...

支持的特效类型：

| 特效       | 说明     | 特效        | 说明   |
| ---------- | -------- | ----------- | ------ |
| grayscale  | 灰度     | opacity     | 透明度 |
| sepia      | 褐色     | brightness  | 亮度   |
| saturate   | 饱和度   | contrast    | 对比度 |
| hue-rotate | 色相旋转 | blur        | 模糊   |
| invert     | 反色     | drop-shadow | 阴影   |

#### 2021年02月16日 周二 08周

do nothing

#### 2021年02月17日 周三 08周

(1)TS+React 打造组件库：添加 normalize.css

(2)TS+React 打造组件库：Button 组件需求分析

* 不同的 Button Type: Primary, Default, Danger, Link Button; 
* 不同的 Button Size: Normal, Small, Large; 
* Disable 的状态：Disabled(普通的不可用), Link Button(链接的不可用); 

```jsx
<Button
  size="lg"
  type="primary"
  disabled
  href="" ?
  className="" ?
  autoFocus="" ?
  ...
  >
  JerryChane Button
</Button>
```

(3)WebRTC学习：从视频中获取图片

1、拿到音视频流
2、点击button拿到该帧
3、使用canvas输出成图片

(4)WebRTC学习：只采集音频数据

#### 2021年02月18日 周四 08周

(1) WebRTC学习：MediaStreamAPI及获取视频约束

MediaStreamAPI

* MediaStream.addTrack()
* MediaStream.removeTrack()
* MediaStream.getVedeoTracks()
* MediaStream.getAudioTracks()

MediaStream 事件API

* MediaStream.onaddtrack
* MediaStream.onremovetrack
* MediaStream.onended

(2)TS+React 打造组件库：Button 组件编码第一部分

```bash
npm install classnames --save
npm install @types/classnames --save
```

(3)TS+React 打造组件库：添加 Button 基本样式

#### 2021年02月19日 周五 08周

(1)TS+React 打造组件库：升级 Button 组件样式

```scss
/*_mixin.scss*/
@mixin button-size($padding-y, $padding-x, $font-size, $border-radius) {
    padding: $padding-y $padding-x;
    font-size: $font-size;
    border-radius: $border-radius;
}

@mixin button-style($background,
    $border,
    $color,
    $hover-background:lighten($background, 7.5%),
    $hover-border:lighten($border, 10%),
    $hover-color: $color) {
    color: $color;
    background: $background;
    border-color: $border;

    &:hover {
        color: $hover-color;
        background: $hover-background;
        border-color: $hover-border;
    }

    &:focus,
    &.focus {
        color: $hover-color;
        background: $hover-background;
        border-color: $hover-border;
    }

    &:disabled,
    &.disabled {
        color: $color;
        background: $background;
        border-color: $border;
    }
}
```

(2)TS+React 打造组件库：精益求精 - Buton 组件编码第二部分

```tsx
// 获取按钮上的属性，并合并
type NativeButtonProps = BaseButtonProps & React.ButtonHTMLAttributes<HTMLElement>
// 获取链接上的属性，并合并
type AnchorButtonProps = BaseButtonProps & React.AnchorHTMLAttributes<HTMLElement>
// 合并所有属性，并导出
export type ButtonProps = Partial<NativeButtonProps & AnchorButtonProps>
```

(3)TS+React 打造组件库：为什么要有测试

国内互联网测试现状

* 重视程度严重不足 、 没有时间、不会写测试

测试的重要性

* 高质量的代码、更早的发现 Bug, 减少成本、让重构和升级变得更加容易和可靠、让开发流程更加敏捷

测试金字塔

* 从下到上：Unit => Service => UI

React 组件特别适合写单元测试

* Component 组件化、 Function 函数 、单向数据流

#### 2021年02月20日 周六 08周

(1)TS+React 打造组件库：通用测试框架 Jest 出场

creat-react-app 脚手架内置了 jest ，可以使用 `npx jest aaa.js --watch` , 来测试

```javascript
test("test common matcher", () => {
    expect(2 + 2).toBe(4);
    expect(2 + 2).not.toBe(5);
});

test("test to be true or false", () => {
    expect(1).toBeTruthy();
    expect(0).toBeFalsy();
});

test("test number", () => {
    expect(4).toBeGreaterThan(3);
    expect(2).toBeLessThan(3);
});
// toBe 表示完全相同，相当于 === toEqual 相当于 ==
test("test object", () => {
    // expect({ name: "jerrychane" }).toBe({ name: "jerrychane" });
    expect({
        name: "jerrychane"
    }).toEqual({
        name: "jerrychane"
    });
});
```

(2)TS+React 打造组件库：React 测试工具 - react-testing-library

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
import React from 'react'
import { render } from '@testing-library/react'
import Button from './button'

test('our first react test case', () => {
    const wrapper = render(<Button>Nice</Button>)
    const element = wrapper.queryByText('Nice')
    expect(element).toBeTruthy()
})
```

运行测试文件： `npm  run test`

(3)TS+React 打造组件库：添加Button 测试代码 第一部分

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
describe('test Button component', () => {
    it('should render the correct  default button', () => {
        const wrapper = render(<Button>Nice</Button>)
        const element = wrapper.getByText('Nice')
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('BUTTON')
        expect(element).toHaveClass('btn btn-default')
    })
    it('should render the correct component based on different props', () => {

    })
    it('should render a link when btnType equals link and href is provided', () => {

    })
    it('should render disabled button when disabled set to true', () => {

    })
})
```

(4)TS+React 打造组件库：添加Button 测试代码 第二部分

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
import React from 'react'
import { render, fireEvent } from '@testing-library/react'
import Button, { ButtonProps, ButtonSize, ButtonType } from './button'

const defaultProps = {
    onClick: jest.fn()
}

const testProps: ButtonProps = {
    btnType: ButtonType.Primary,
    size: ButtonSize.Large,
    className: 'klass'
}
const disabledProps: ButtonProps = {
    disabled: true,
    onClick: jest.fn()
}

describe('test Button component', () => {
    it('should render the correct  default button', () => {
        const wrapper = render(<Button {...defaultProps}>Nice</Button>)
        const element = wrapper.getByText('Nice') as HTMLButtonElement
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('BUTTON')
        expect(element).toHaveClass('btn btn-default')
        expect(element.disabled).toBeFalsy()
        fireEvent.click(element)
        expect(defaultProps.onClick).toBeCalled()
    })
    it('should render the correct component based on different props', () => {
        const wrapper = render(<Button {...testProps}>Nice</Button>)
        const element = wrapper.getByText('Nice')
        expect(element).toBeInTheDocument()
        expect(element).toHaveClass('btn-primary btn-lg klass')
    })
    it('should render a link when btnType equals link and href is provided', () => {
        const wrapper = render(<Button btnType={ButtonType.Link} href="https://jerrychane.com" >Link</Button>)
        const element = wrapper.getByText('Link')
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('A')
        expect(element).toHaveClass('btn btn-link')
    })
    it('should render disabled button when disabled set to true', () => {
        const wrapper = render(<Button {...disabledProps}>Nice</Button>)
        const element = wrapper.getByText('Nice') as HTMLButtonElement
        expect(element).toBeInTheDocument()
        expect(element.disabled).toBeTruthy()
        fireEvent.click(element)
        expect(disabledProps.onClick).not.toHaveBeenCalled()
    })
})
```

#### 2021年02月21日 周日 08周

do nothing

#### 2021年02月22日 周一 09周

(1)TS+React 打造组件库：Menu 组件需求分析

以下均为伪代码：

```js
// 一个不那么完美的解决方案
const items = [{
            disabled: false,
            element: ( < a > title < /a>)}, {
                    disabled: true,
                    element: 'cool link'
                }] <
                Menu defaultIndex = {
                    0
                }
            items = {
                items
            }
            onSelect = {}
            mode = "vertical" > < /Menu>
```

```js
// 更加语义化，更像 HTML 的解决方案
<
Menu defaultIndex = {
    0
}
onSelect = {}
mode = "vertical" >
    <
    Menu.item > title one < /Menu.item> <
    Menu.item disabled > disabled link < /Menu.item> <
    Menu.item > < a href = "https://www.google.com" > Google! < /a></Menu.item >
    <
    /Menu>
// 属性分析
interface MenuProps {
    activeIndex: number;
    mode: string; // 某种常量
    onSelect: (selectedIndex: number) => voild
    className: string;
}
interface MenuItemProps {
    index: number;
    disabled: boolean;
    className: string;
}
```

(2)TS+React 打造组件库：基础架构 - Menu组件编码第一部分

```tsx
import React from 'react'
import classNames from 'classnames'

type MenuMode = 'horizontal' | 'vertical'
export interface MenuProps {
    defaultIndex?: number;
    className?: string;
    mode?: MenuMode;
    style?: React.CSSProperties;
    onSelect?: (selectedIndex: number) => void
}

const Menu: React.FC<MenuProps> = (props) => {
    const { defaultIndex, className, mode, style, children } = props
    const classes = classNames('jerrychane-menu', className, {
        'menu-vertical': mode === 'vertical'
    })
    return (
        <ul className={classes} style={style}>
            {children}
        </ul>
    )
}

Menu.defaultProps = {
    defaultIndex: 0,
    mode: 'horizontal'
}

export default Menu;
```

(3)TS+React 打造组件库：需求升级 - Menu 组件编码第二部分

#### 2021年02月23日 周二  09周

(1)TS+React 打造组件库：添加 Menu 样式

```html
https://css-tricks.com/snippets/css/a-guide-to-flexbox/
```

#### 2021年02月24日 周三  09周

(1)TS+React 打造组件库：测试驱动-Menu 测试添加

```tsx
//jerrychaneui/src/components/Menu/menu.test.tsx
import React from 'react'
import { cleanup, fireEvent, render, RenderResult } from '@testing-library/react'
import Menu, { MenuProps } from './menu'
import MenuItem from './menuItem'

const testProps: MenuProps = {
    defaultIndex: 0,
    onSelect: jest.fn(),
    className: 'test'
}

const testVerticalProps: MenuProps = {
    defaultIndex: 0,
    mode: 'vertical'
}

const generateMenu = (props: MenuProps) => {
    return (
        <Menu {...props}>
            <MenuItem index={0}>active</MenuItem>
            <MenuItem disabled index={1}>disabled</MenuItem>
            <MenuItem index={2}>xyz</MenuItem>
        </Menu>
    )
}
let wrapper: RenderResult, menuElement: HTMLElement, activeElement: HTMLElement, disabledElement: HTMLElement
describe('test Menu and MenuItem component', () => {
    beforeEach(() => {
        wrapper = render(generateMenu(testProps))
        menuElement = wrapper.getByTestId('test-menu')
        activeElement = wrapper.getByText('active')
        disabledElement = wrapper.getByText('disabled')
    })
    it('should render correct Menu and MenuItem based default props', () => {
        expect(menuElement).toBeInTheDocument()
        expect(menuElement).toHaveClass('viking-menu test')
        expect(menuElement.getElementsByTagName('li').length).toEqual(3)
        expect(activeElement).toHaveClass('menu-item is-active')
        expect(disabledElement).toHaveClass('menu-item is-disabled')

    })
    it('click items should change active and call the right callback', () => {
        const thirdItem = wrapper.getByText('xyz')
        fireEvent.click(thirdItem)
        expect(thirdItem).toHaveClass('is-active')
        expect(activeElement).not.toHaveClass('is-active')
        expect(testProps.onSelect).toHaveBeenCalledWith(2)
        fireEvent.click(disabledElement)
        expect(disabledElement).not.toHaveClass('is-active')
        expect(testProps.onSelect).not.toHaveBeenCalledWith(1)
    })
    it('should render vertical mode when mode is set to vertical', () => {
        cleanup()
        const wrapper = render(generateMenu(testVerticalProps))
        const menuElement = wrapper.getByTestId('test-menu')
        expect(menuElement).toHaveClass('menu-vertical')
    })
})
```

#### 2021年02月25日 周四  09周

(1)TS+React 打造组件库：日趋完美 - Menu 组件编码第三部分

```tsx
 const renderChildren = () => {
        return React.Children.map(children, (child, index) => {
            const childElement = child as React.FunctionComponentElement<MenuItemProps>
            const { displayName } = childElement.type
            if (displayName === "MenuItem") {
                return React.cloneElement(childElement, { index })
            } else {
                console.error('Warning: Menu has a child which is not a MenuItem component!')
            }
        })
    }
    return (
        <ul className={classes} style={style} data-testid="test-menu">
            <MenuContext.Provider value={passContext}>
                {renderChildren()}
            </MenuContext.Provider>
        </ul>
    )
```

#### 2021年02月27日 周六  09周

(1)TS+React 打造组件库：功能继续升级 - SubMenu 下拉菜单编码第一部分

```jsx
// 更加语义化 更加像 HTML 的解决方案
<Menu defaultIndex={0} onSelect={}>
  <Menu.Item index={"0"}>title one</Menu.Item>
  <Menu.Item disalbed  index={"1"}>disalbed link</Menu.Item>
  <Menu.SubMenu title={'test'}  index={"2"}> 
  	<Menu.Item index={"2-0"}>cool link</Menu.Item>
    <Menu.Item index={"2-1"}>cool link</Menu.Item>
  </Menu.SubMenu>
  <Menu.Item index={"3"}><a href="https://www.google.com">Google</a></Menu.Item>
</Menu>
```

(2)TS+React 打造组件库：添加交互 - SubMenu下拉菜单编码第二部分

```tsx
import React, { useContext, useState, FunctionComponentElement } from 'react'
import classNames from 'classnames'
import { MenuContext } from './menu'
import { MenuItemProps } from './menuItem'

export interface SubMenuProps {
    index?: number;
    title?: string;
    className?: string;
}

const SubMenu: React.FC<SubMenuProps> = ({ index, title, children, className }) => {
    const context = useContext(MenuContext)
    const [menuOpen, setOpen] = useState(false)
    const classes = classNames('menu-item submenu-item', className, {
        'is-active': context.index === index
    })
    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault()
        setOpen(!menuOpen)
    }
    let timer: any
    const handleMouse = (e: React.MouseEvent, toggle: boolean) => {
        clearTimeout(timer)
        e.preventDefault()
        timer = setTimeout(() => {
            setOpen(toggle)
        }, 300)
    }
    const clickEvents = context.mode === 'vertical' ? { onClick: handleClick } : {}
    const hoverEvents = context.mode !== 'vertical' ? {
        onMouseEnter: (e: React.MouseEvent) => { handleMouse(e, true) },
        onMouseLeave: (e: React.MouseEvent) => { handleMouse(e, false) },
    } : {}
    const renderChildren = () => {
        const subMenuClasses = classNames('viking-submenu', {
            'menu-opened': menuOpen
        })
        const childrenComponent = React.Children.map(children, (child, i) => {
            const childElement = child as FunctionComponentElement<MenuItemProps>
            if (childElement.type.displayName === "MenuItem") {
                return childElement
            } else {
                console.error('Warning:SubMenu has a child which is not a MenuItem component')
            }
        })
        return (
            <ul className={subMenuClasses}>{childrenComponent}</ul>
        )
    }
    return (
        <li key={index} className={classes} {...hoverEvents}>
            <div className='submenu-title' onClick={handleClick} {...clickEvents}>{title}</div>
            {renderChildren()}
        </li>
    )
}
SubMenu.displayName = 'SubMenu'
export default SubMenu
```

#### 2021年02月28日 周日  09周

(1)TS+React 打造组件库：大功告成 - SubMenu 下拉菜单编码第三部分

把 index 的类型要定义成 string 类型; 

(2)TS+React 打造组件库：完美组件 - SubMenu 组件添加测试

```tsx
it('should show dropdown items when hover on subMenu', async () => {
        expect(wrapper.queryByText('drop1')).not.toBeVisible()
        const dropdownElement = wrapper.getByText('dropdown')
        fireEvent.mouseEnter(dropdownElement)
        await waitFor(() => {
            expect(wrapper.queryByText('drop1')).toBeVisible()
        })
        fireEvent.click(wrapper.getByText('drop1'))
        expect(testProps.onSelect).toHaveBeenCalledWith('3-0')
        fireEvent.mouseLeave(dropdownElement)
        await waitFor(() => {
            expect(wrapper.queryByText('drop1')).not.toBeVisible()
        })
    })
```

#### 2021年03月02日 周二  10周

(1)TS+React 打造组件库：图标解决方案简介

图标 Icon 的解决方案

* 上古时期 - 雪碧图 （CSS Sprite）
* 近代- Font Icon
* 现代和未来 - SVG

SVG 的优势

* 完全可控
* SVG 即取即用，Font Icon 要下载全部字体文件
* Font Icon 还有很多奇怪的 Bug

 

```bash
npm i --save @fortawesome/fontawesome-svg-core
npm install --save @fortawesome/free-solid-svg-icons
npm install --save @fortawesome/react-fontawesome
```

How to use fontawesome

```jsx
import ReactDOM from 'react-dom'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faCoffee } from '@fortawesome/free-solid-svg-icons'
const element = <FontAwesomeIcon icon={faCoffee} />
ReactDOM.render(element, document.body)
```

#### 2021年03月04日 周四  10周

(1)TS+React 打造组件库：他山之石 - Icon组件编码第一部分

```tsx
import Icon from './components/Icon/icon'
import { library } from '@fortawesome/fontawesome-svg-core'
import { fas } from '@fortawesome/free-solid-svg-icons'
library.add(fas)
<Icon icon="arrow-down" theme="danger" size="10x" />
```

(2)TS+React 打造组件库：Icon 组件样式添加

```scss
// /src/styles/_variables.scss
$theme-colors: ("primary": $primary,
    "secondary": $secondary,
    "success": $success,
    "info": $info,
    "warning": $warning,
    "danger": $danger,
    "light": $light,
    "dark": $dark,
);
// /src/components/Icon/_style.scss
@each $key,
$val in $theme-colors {
    .icon-#{$key} {
        color: $val;
    }
}
```

(3)TS+React 打造组件库：让图标动起来 - 动画效果第一种实现方法

#### 2021年03月05日 周五  10周

(1)TS+React 打造组件库：React Transiton Group 简介

当 display 从 none 变为 block 的过程中，其他的动画特效会失效，因为 display 不是一个标准的可以支持 animation 的属性。

当 display 和 opacity 放在一起时，opacity 不会生效。

```
// 逐渐显示
display:none ===> display:block;opcity:0;===> display:block;opacity:1
// 逐渐隐藏
display:block;opacity:1 ===> display:block;opcity:0; ===> display:none
```

React Transiton Group 本身没有实现任何的动画效果，非常轻量级，它只是定义了组件进入和离开时的不同 className, 需要我们自己添加样式，实现动画效果。

```jsx
function App() {
  const [inProp, setInProp] = useState(false);
  return (
    <div>
      <CSSTransition in={inProp} timeout={200} classNames="my-node">
        <div>
          {"I'll receive my-node-* classes"}
        </div>
      </CSSTransition>
      <button type="button" onClick={() => setInProp(true)}>
        Click to Enter
      </button>
    </div>
  );
}
```

```CSS
.my-node-enter {
    opacity: 0;
}

.my-node-enter-active {
    opacity: 1;
    transition: opacity 200ms;
}

.my-node-exit {
    opacity: 1;
}

.my-node-exit-active {
    opacity: 0;
    transition: opacity 200ms;
}
```

```
*-enter => forces a reflow 添加动画效果 => *-enter-active => 自定义timeout=> *-enter-done
*-exit => forces a reflow 添加动画效果 => *-exit-active => 自定义timeout=> *-exit-done
```

(2)TS+React 打造组件库：React Transition Group 实践 - 动画效果第二种实现方式

```shell
npm install react-transition-group@4.3.0 --save
npm install @types/react-transition-group@4.3.0 --save
```

(3)TS+React 打造组件库：尽善尽美 - React Transition Group 添加菜单消失的动画

```
https://reactcommunity.org/react-transition-group/transition
```

(4)TS+React 打造组件库：拿来主义 - 自定义 Transition 组件编码第一部分

```jsx
// 伪代码
<CSSTransition in={open} timeout={300} className="my-node" appear unmoutOnExit>
{node}
</CSSTransition>
// 进化后
<Transition in={open} timeout={300} animation="zoom-in-top">
{node}
</Transition>
```

#### 2021年03月06日 周六  10周

(1)TS+React 打造组件库: 拿来主义 - 自定义 Transition 组件编码第二部分

(2)TS+React 打造组件库: 完成的 Icon 和 Transition 组件

(3)TS+React 打造组件库: 什么是 Storybook

目前开发的痛点：

* create-react-app 入口文件不适合管理组件库
* 缺少行为追踪和属性调试功能

完美组件开发工具应有的特点

* 分开展示各个组件不同属性下的状态
* 能追踪组件的行为并且具有属性调试功能
* 可以为组件自动生成文档和属性列表

(4)TS+React 打造组件库: 安装 Storybook

```
# Add Storybook:
npx sb init 
```

(5)TS+React 打造组件库: Storybook 支持 Typescript

storybook 6.0 版本支持以下配置来使用 typescript

```js
// .storybook/main.js
module.exports = {
    typescript: {
        check: false,
        checkOptions: {},
        reactDocgen: 'react-docgen-typescript',
        reactDocgenTypescriptOptions: {
            shouldExtractLiteralValuesFromEnum: true,
            propFilter: (prop) => (prop.parent ? !/node_modules/.test(prop.parent.fileName) : true),
        },
    },
};
```

(6)TS+React 打造组件库: 展示秀- 为 Button 添加 Story

* Component Story Format
* storiesOf API
* MDX syntax

#### 2021年03月07日 周日  10周

(1)TS+React 打造组件库: 展示秀- 为 Button 添加 Story

```tsx
// jerrychaneui/src/components/Button/button.stories.tsx
import React from 'react'
import { storiesOf } from '@storybook/react'
import { action } from '@storybook/addon-actions'

import Button from './button'

const defaultButton = () => {
    return <Button onClick={action('clicked')}> default button </Button>
}
const buttonWithSize = () => (
    <>
        <Button size="lg">large button</Button>
        <Button size="sm">small button</Button>
    </>
)
const buttonWithType = () => (
    <>
        <Button btnType="primary">primary button</Button>
        <Button btnType="danger">danger button</Button>
        <Button btnType="link" href="https://google.com">link button</Button>
    </>
)
storiesOf('Button Component', module)
    .add('默认Button', defaultButton)
    .add('不同尺寸的 Button', buttonWithSize)
    .add('不同类型的 Button', buttonWithType)
```

(2)TS+React 打造组件库: 如虎添翼 - Stroybook addon插件系统介绍

(3)TS+React 打造组件库: 更多信息 - 添加 Storybook addon-info 插件

```shell
npm i -D @storybook/addon-info@5.2.8
npm install --save @types/storybook__addon-info@5.2.1
```

#### 2021年03月08日 周一  11周

(1)TS+React 打造组件库: 更多信息 - 添加 Storybook addon-info 插件

其中 text 参数支持 markdown 书写语法

```tsx
// jerrychaneui/src/components/Button/button.stories.tsx
storiesOf('Button Component', module)
    .addDecorator(withInfo)
    .addParameters({
        info: {
            text: `
            this is a very nice component
            ### this is a header
            ~~~js
                const a = 'hello'
            ~~~
            `,
            inline: true
        }
    })
    .addDecorator(CenterDecorator)
    .add('默认Button', defaultButton)
    .add('不同尺寸的 Button', buttonWithSize, { info: { inline: false } })
    .add('不同类型的 Button', buttonWithType)
```

(2)TS+React 打造组件库: 自动生成文档 - 添加 react-docgen-typescript 第一部分

```bash
npm install --save-dev react-docgen-typescript-loader@3.6.0
```

(3)TS+React 打造组件库: 自动生成文档 - 添加 react-docgen-typescript 第二部分

(4)TS+React 打造组件库: 大功告成 - Storybook 最终样式调整

(5)TS+React 打造组件库: 知己知彼 -Input 组件需求分析

```jsx
// 伪代码
<Input
	disabled
  size="lg||sm"
  icon="fontawesome 支持的图标"
  prepand="input 前缀，string 或 ReactElement"
  append="input 后缀，string 或 ReactElement"
  {...restProps} 支持其他所有的 HTMLInput 属性
/>
```

(6)TS+React 打造组件库: 抛砖引玉 - Input 组件伪代码实现

```tsx
import React, { FC, ReactElement, InputHTMLAttributes } from 'react'
import { IconProp } from '@fortawesome/fontawesome-svg-core'
import { IconProps } from '../Icon/icon'

type InputSize = 'lg' | 'sm'

export interface InputProps extends Omit<InputHTMLAttributes<HTMLElement>, 'size'> {
    disabled?: boolean;
    size?: InputSize;
    icon?: IconProps;
    prehand?: string | ReactElement;
    append?: string | ReactElement;
}

export const Input: FC<InputProps> = (props) => {
    // 取出各种的属性
    // 根据属性计算不同的 className

    return (
        // 根据属性判断是否要添加特定的节点
        <></>
    )
}
```

#### 2021年03月10日 周三  11周

(1）TS+React 打造组件库: 持续优化 - Input组件代码实现和优化过程

#### 2021年03月12日 周五  11周

(1）TS+React 打造组件库: 新的挑战 - AutoComplete组件分析

```
// custom option
// keyboard support
// debource
// click outside
```

(2）TS+React 打造组件库: AutoComplete 编码第一部分

#### 2021年03月13日 周六  11周

(1）TS+React 打造组件库:  AutoComplete 支持自定义模板

```tsx
 const renderTemplate = (item: DataSourceTpye) => {
        return renderOption ? renderOption(item) : item.value
    }
```

(2）TS+React 打造组件库:  异步来了 - AutoComplete 支持异步请求编码

#### 2021年03月14日 周日  11周

(1）TS+React 打造组件库:  老瓶新酒 - 使用自定义Hook实现 函数防抖 debounce

Lodash 里有一个写好的解决方案，其实函数防抖的原理也非常简单，它通过闭包保存一个标记，来保存 setTimeout 返回的值，每当用户输入时，就把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout, 这样就能够保证输入的时间间隔内还有字符输入的话，就不会执行这个回调函数了。

```tsx
import { useState, useEffect } from 'react'
function useDebounce(value: any, delay: 300) {
    const [debounceValue, setDebounceValue] = useState(value)
    useEffect(() => {
        const handler = window.setTimeout(() => {
            setDebounceValue(value)
        }, delay)
        return () => {
            clearTimeout(handler)
        }
    }, [value, delay])
    return debounceValue
}

export default useDebounce;
```

(2）TS+React 打造组件库:  AutoComplete 支持键盘事件

```jsx
const highlight = (index: number) => {
        if (index < 0) index = 0
        if (index >= suggestions.length) {
            index = suggestions.length - 1
        }
        setHighlightIndex(index)
    }
    const handleOnKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
        switch (e.keyCode) {
            // enter
            case 13:
                if (suggestions[hightlightIndex]) {
                    handleSelect(suggestions[hightlightIndex])
                }
                break;
            // up
            case 38:
                highlight(hightlightIndex - 1)
                break;
            // down
            case 40:
                highlight(hightlightIndex + 1)
                break;
            // esc
            case 27:
                setSuggestions([])
                break;
            default:
                break;
        }
    }
```

(3)TS+React 打造组件库: 妙用 useRef - 实现 clickOutSide 功能

```tsx
const triggerSearch = useRef(false)
const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      const value = e.target.value.trim()
      setInputValue(value)
      triggerSearch.current = true
  }
const handleSelect = (item: DataSourceType) => {
    setInputValue(item.value)
    setSuggestions([])
    if (onSelect) {
        onSelect(item)
    }
    triggerSearch.current = false
}
```

```tsx
import { RefObject, useEffect } from 'react'
//  点击外侧区域，下拉框消失
function useClickOutside(ref: RefObject<HTMLElement>, handler: Function) {
    useEffect(() => {
        const listener = (event: MouseEvent) => {
            if (!ref.current || ref.current.contains(event.target as HTMLElement)) {
                return
            }
            handler(event)
        }
        document.addEventListener('click', listener)
        return () => {
            document.removeEventListener('click', listener)
        }
    }, [ref, handler])
}

export default useClickOutside;
```

(3)TS+React 打造组件库: AutoComplete 添加单元测试

运行部分组件的测试用例：

```shell
npm test -- -t "auto"
```

#### 2021年03月16日 周二  12周

(1)TS+React 打造组件库: 最终任务 -Upload 组件需求分析

Upload 一个文件的生命周期：

```
开始 => 点击按钮&选择文件 => beforeUpload(file) => onProgress(event,file)  =>  onChange(file)  =>  onSuccess(response,file) || onError(error,file)
onSuccess(response,file) => 点击已经上传的删除按钮  => onRemoved(file)
```

伪代码如下：

```tsx
<Upload
   action="https://upload!"
   beforeUpload={() => {}}
   onProgress={() => {}}
   onChange={() => {}}
   onSuccess={() => {}}
   onError={() => {}}
   onRemoved={() => {}}
  >
	<Button>click to upload</Button>
</Upload>
```

(2)TS+React 打造组件库: 下一代 HTTP 库 - axios

Fetch 的缺点：

* 只对网络请求报错，对 400，500 都当做成功的请求
* 默认不会带 cookie
* 不支持 abort, 不支持超时控制
* 没有办法原生监控请求的进度

(3)TS+React 打造组件库: 在线 mock server 和 axios 简单使用

```
npm i axios --save
```

#### 2021年03月17日 周三  12周

(1)TS+React 打造组件库: 上传文件的基本方式

HTML 表单提供三种文件的编码：application/x-www-form-urlencoded(the default) ; multipart/form-data ; text/plain

```tsx
import React, { useState, useEffect, ChangeEvent } from 'react';
import axios from 'axios'

const App: React.FC = () => {
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (files) {
      const uploadedFile = files[0]
      const formData = new FormData()
      formData.append(uploadedFile.name, uploadedFile)
      axios.post('http://jsonplaceholder.typicode.com/posts', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      }).then(resp => {
        console.log(resp)
      })
    }
  }
  return (
    <div className="App" style={{ marginTop: '100px', marginLeft: '100px' }}>
      <input type="file" name="myFile" onChange={handleFileChange} />
    </div>
  )
}

export default App;
```

(2)TS+React 打造组件库: 完成基本流程 - Upload 组件编码第一部分

(3)TS+React 打造组件库: 完成基本流程 - Upload 组件编码第二部分

#### 2021年03月18日 周四  12周

(1)TS+React 打造组件库: 创建列表数据 - UploadList 组件编码第一部分

```js
// 获取上传文件的各种状态
const updateFileList = (updateFile: UploadFile, updateObj: Partial < UploadFile > ) => {
    setFileList(prevList => {
        return prevList.map(file => {
            if (file.uid === updateFile.uid) {
                return {
                    ...file,
                    ...updateObj
                }
            } else {
                return file
            }
        })
    })
}
```

#### 2021年03月19日 周五  12周

(1)TS+React 打造组件库: 显示上传数据 - UploadList 组件编码第二部

```tsx
import React, { FC } from 'react'
import { UploadFile } from './upload'
import Icon from '../Icon/icon'
import { faCheckCircle, faFileAlt, faSpinner, faTimes, faTimesCircle } from '@fortawesome/free-solid-svg-icons'
interface UploadListProps {
    fileList: UploadFile[];
    onRemove: (_file: UploadFile) => void;
}

export const UploadList: FC<UploadListProps> = (props) => {
    const { fileList, onRemove } = props
    return (
        <ul className="viking-upload-list">
            {fileList.map(item => {
                return (
                    <li className="viking-upload-list-item" key={item.uid}>
                        <span className={`file-name file-name-${item.status}`}>
                            <Icon icon={faFileAlt} theme="secondary" />
                            {item.name}
                        </span>
                        <span className="file-status">
      {item.status === "uploading" && <Icon icon={faSpinner} theme="primary" />}
      {item.status === "success" && <Icon icon={faCheckCircle} theme="success" />}
      {item.status === "error" && <Icon icon={faTimesCircle} theme="danger" />}
                        </span>
                        <span className="file-actions">
                            <Icon icon={faTimes} onClick={() => { onRemove(item) }} />
                        </span>
                    </li>
                )
            })}
        </ul>
    )
}

export default UploadList;
```

(2)TS+React 打造组件库: 显示上传进度 - 添加 Progress 组件

(3)TS+React 打造组件库: 精益求精 - 再次分析 Upload 组件更近一步需

丰富化上传数据

* 添加自定义 Header
* 添加 name 属性 - 代表发到后台的文件参数名称
* 添加 data 属性 - 上传所需要的额外参数
* 添加 input 本身的 file 约束属性 - multiple, accept 等

展示更丰富的界面和交互

* 自定义出发的元素
* 支持拖动上传文件
* 点击上传文件名称，添加 onPreview 事件

#### 2021年03月20日 周六  12周

(1)TS+React 打造组件库: Upload 增强交互第一部分

自定义 HTTP post 请求：

* 添加自定义 header
* 添加自定义 name
* 添加自定义 post formData
* 添加自定义 cookie-withCredentials

自定义 input 属性

* 添加 multiple 属性
* 添加 accept 属性

(2)TS+React 打造组件库: 拖动上传 - 支持 Drag and Drop

```
初始状态 => 触发 DragOver => 添加特定 class:is-dragover => DragLeave 或 onDrop
DragLeave => 删除特定 class: is-dragover
onDrop => 删除特定 class,并且触发 onFile 事件，将 FileList 传递出去
```

#### 2021年03月21日 周日  12周

(1)TS+React 打造组件库: 异步怎样测试？ - Upload 测试第一部分

(2)TS+React 打造组件库: Javascript 模块化发展历史

```js
// common.js 服务端常用
const bar = require('./bar')
// 模块产出
module.exports = function() {
    // ...
};

// AMD
define(function(require) {
    // 通过相对路径获得依赖模块
    const bar = require('./bar')
    // 模块产出
    return function() {
        //...
    };
});

// es6 module
// 通过相对路径获得依赖模块
import bar from './bar'
// 模块产出
export default function() {
    // ...
};
```

(3)TS+React 打造组件库: webpack 到底完成什么任务？ - bundler的神奇功效

#### 2021年03月22日 周一  13周

(1)TS+React 打造组件库: 怎么选择 Javascript 模块格式（ES Module）

(2)TS+React 打造组件库: 创建组件库模块入口文件

```tsx
// /src/components/Menu/index.tsx
import { FC } from 'react'
import Menu, { MenuProps } from './menu'
import MenuItem, { MenuItemProps } from './menuItem'
import SubMenu, { SubMenuProps } from './subMenu'
export type IMenuComponent = FC<MenuProps> & {
    Item: FC<MenuItemProps>,
    SubMenu: FC<SubMenuProps>,
}
const TransMenu = Menu as IMenuComponent;

TransMenu.Item = MenuItem;
TransMenu.SubMenu = SubMenu;

export default TransMenu;
```

(3)TS+React 打造组件库: 驯服tsc - tsconfig 编写第一部分

(4)TS+React 打造组件库: 驯服tsc - tsconfig 编写第二部分

#### 2021年03月23日 周二  13周

(1)TS+React 打造组件库: 生成最终使用的样式文件

```bash
"build-css":"node-sass ./src/styles/index.scss ./build/index.css",
```

```
npm i rimraf --save-dev
```

(2)TS+React 打造组件库: 使用 npm link 本地测试组件库 第一部分

```
在 vikingship 文件夹 => npm link => 创建软连接到全局 node/v12.5.0/lib/node_modules
在 vikingtest 文件夹中 => npm link vikingship => 在 vikingship/node_modules 中创建软连接到全局
```

(3)TS+React 打造组件库: 使用 npm link 本地测试组件库 第三部分

#### 2021年03月24日 周三  13周

(1)TS+React 打造组件库: 瘦身任务 - 精简 package.json 依赖

```json
 "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^1.2.26",
    "@fortawesome/free-solid-svg-icons": "^5.12.0",
    "@fortawesome/react-fontawesome": "^0.1.8",
    "axios": "^0.21.1",
    "classnames": "^2.2.6",
    "react": "^16.12.0",
    "react-dom": "^16.12.0",
    "react-transition-group": "^4.3.0",
    "web-vitals": "^1.1.0"
  },
 "peerDependencies": {
    "react": ">=16.8.0",
    "react-dom": ">=16.8.0"
  },
  "devDependencies": {
    "react-scripts": "3.2.0",
    "babel-loader": "^8.2.2",
    "node-sass": "^4.13.0",
    "typescript": "3.7.2",
    "@types/classnames": "^2.2.9",
    "@types/jest": "24.0.23",
    "@types/node": "12.12.14",
    "@types/react": "^16.9.13",
    "@types/react-dom": "16.9.4",
    "@types/react-transition-group": "^4.2.3",
    "@storybook/addon-actions": "^5.2.8",
    "@storybook/addon-info": "^5.2.8",
    "@storybook/addon-links": "^5.2.8",
    "@storybook/addons": "^5.2.8",
    "@storybook/react": "^5.2.8",
    "@testing-library/jest-dom": "^4.2.4",
    "@testing-library/react": "^9.3.2",
    "react-docgen-typescript-loader": "^3.6.0",
    "rimraf": "^3.0.2"
  }
```

(2)TS+React 打造组件库: 万无一失 - 添加发布和 commit 前检查

```bash
npm install husky --save-dev
```

(3)TS+React 打造组件库: 使用 Storybook 生成静态文档页面

(4)TS+React 打造组件库: CI CD 简介

CI-持续集成：

* 频繁的将代码集成到主干（master）
* 快速发现错误
* 防止分支大幅偏离主干

CD-持续交付、持续部署

* 频繁的将软件的新版本，交付给质量团队或者用户
* 代码通过评审以后，自动部署到生产环境

(5)TS+React 打造组件库: 使用 travis 自动运行测

(6)TS+React 打造组件库: 使用 travis 自动发布文档页面

#### 2021年03月25日 周四  13周

(1) WebRTC Learn：MediaStreamAPI及获取视频约束

```js
//MediaStrem 媒体流 & 音轨 & 视频轨
MediaStrem.addTrack()
MediaStrem.removeTrack()
MediaStrem.getVideoTracks()
MediaStrem.getAudioTracks()
// MediaStrem 事件
MediaStrem.onaddtrack()
MediaStrem.onremovetrack()
MediaStrem.onended()
```

(2) WebRTC Learn：录制基本知识 - MediaRecoder 基本格式

```js
var mediaRecorder = new mediaRecorder(stream[, options])
```

| 参数   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| stream | 媒体流，可以通过 getUserMedia、` `<video>`  `、` <audio> `或` <canvas> `获取 |
| option | 限制选项                                                     |

MediaRecoder 参数即 option

| 选项               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| mimeType           | video/webm<br />audio/webm<br /> vedio/webm; codecs=vp8<br /> vedio/webm; codecs=h264<br /> vedio/webm; codecs=opus<br /> |
| audioBitsPerSecond | 音频码率                                                     |
| videoBitsPerSecond | 视频码率                                                     |
| bitsPersecond      | 整体码率                                                     |

JS 存储数据的方式： 字符串、Blob（常用）、ArrayBuffer、ArrayBufferView

(3) WebRTC Learn：录制音视频实战-1

#### 2021年03月26日 周五  13周

(1) WebRTC Learn：录制音视频实战-2

```js
btnDownload.onclick = () => {
    var blob = new Blob(buffer, {
        type: "video/webm"
    });
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.style.display = "none";
    a.download = "aaa.webm";
    a.click();
}
```

(2) WebRTC Learn：采集屏面数据

```js
// 基本格式
var promise = navigator.mediaDevices.getDisplayMedia(constraints);
```

constraints 可选，constraints 中约束与 getUserMedia 函数中的一致。

(3) WebRTC Learn：如何使用 socket.io 发送消息

Socket.io 发送消息（一）

* 给本次连接发送消息：`socket.emit()`
* 给某个房间内所有人发消息：`io.in(room).emit()`

Socket.io 发送消息（二）

* 除本连接外，给某个房间内所有人发消息：`socket.to(room).emit()`
* 除本连接外，给所有任务发消息：`socket.broadcast.emit()`

Socket. IO 客户端处理消息(一)

* 发送 action 命令：

```js
S: socket.emit('action')
C: socket.on('action', function() {
    ...
})
```

* 发送了一个 action 命令，还有 data 数据

```js
S: socket.emit('action', data)
C: socket.on('action', function(data) {
    ...
})
```

Socket. IO 客户端处理消息(二)

* 发送了 action 命令，还有两个数据

```js
S: socket.emit('action', arg1, arg2)
C: socket.on('action', function(arg1, arg2) {
    ...
})
```

* 发送了一个 action 命令，在 emit 方法中包含回调函数 

```js
S: socket.emit('action', data, function(arg1, arg2) {
    ...
})
C: socket.on('action', function(data, fn) {
            fn('a', 'b');)
```

(4) WebRTC Learn：信令服务器原理

为什么要使用 socket.io

* socket.io 是 WebSocket 的超集
* socket.io 有房间的概念
* socket.io 跨平台、跨终端、跨语言

#### 2021年03月27日 周六  13周

(1) WebRTC Learn：信令服务器的实现

改造服务端的基本流程：

* 安装 soket.io
* 引入 soket.io
* 处理 connection 消息

(2) WebRTC Learn：利用socket.io实现简单聊天室1 & 2

#### 2021年03月28日 周日  13周

(1) WebRTC Learn：网络传输基本知识

* NAT(Network Address Translator) 内网地址
* STUN（Simple Traversal of UDP Through NAT）公网地址
* TURN（Traversal Using Relays around NAT）
* ICE (Interactive Connectivity Establishment)

| NAT 产生原因 | (1)IPv4 地址不够；(2) 出于网络安全                    |
| ------------ | ----------------------------------------------------- |
| NAT 种类     | (1)完全锥型；(2) 地址限制型；(3)端口限制型；(4)对称型 |

(2) WebRTC Learn：NAT打洞原理

* C1、C2 向 STUN 发送消息
* 交换公网 IP  及端口
* C1=>C2 , C2=>C1, 甚至是端口猜测、

(3) WebRTC Learn：NAT类型检测

(4) WebRTC Learn：STUN 协议一

* 目的：进行 NAT 穿越
* 模式：典型的客户端/服务端。客户端发送请求，服务端进行响应
* header: 包含 20 字节的 STUN header
* body: 可以有0个或多个 Atrribute

(5) WebRTC Learn：STUN 协议二

#### 2021年03月29日 周一  14周

(1) WebRTC Learn：TRUN 协议

* 目的是解决对称 NAT 无法穿越的问题
* 其建立在 STUN 之上，消息格式使用 STUN 格式消息
* TURN Client 要求服务端分配一个公共 IP 和 Port 用于接收或发送数据

TRUN 使用的传输协议

| TURN client to TURN server | TURN server to peer |
| -------------------------- | ------------------- |
| UDP/TCP/TLS over TCP       | UDP/UDP/UDP         |

TRUN 发送机制：Send & Data ; Chanel

TRUN 的使用

```
1.STUN binding
Caller TURN allocation
Caller sends offer
Callee TURN allocation
Callee answers OK
Exchange candidate IP address
ICE check for P2P connection
If P2P unsuccessful,make relay connection
```

(2) WebRTC Learn：【协议规范】ICE框架

(3) WebRTC Learn：网络分析方法 tcpdump 与 wireshark讲解

常用工具：Linux 服务端用 tcpdump 、其他端 WireShark

#### 2021年03月30日 周二  14周

(1) WebRTC Learn：网络分析方法 tcpdump 与 wireshark 实战-2

(2) WebRTC Learn：媒体能力协商过程一，端对端连接

RTCPeerConnection

```js
// 基本格式
pc = new RTCPeerConnection([configuration])
```

RTCPeerConnection 方法分类

* 媒体协商
* Stream / Track
* 传输相关方法
* 统计相关方法

(3) WebRTC Learn：媒体能力协商过程二

媒体协商的方法：

```js
// createOffer
aPromise = myPeerConnection.createOffer([options])
// createAnswer
aPromise = myPeerConnection.createAnswer([options])
// setLocalDescription
aPromise = myPC.setLocalDescription([sessionDescription])
// setRemoteDescription
aPromise = myPC.setRemoteDescription([sessionDescription])
```

#### 2021年03月31日 周三  14周

(1) WebRTC Learn：1:1 连接的基本流程，端对端连接的基本流程

(2) WebRTC Learn：本机内的1:1 音视频互通-1

#### 2021年04月01日 周四  14周

(1)WebRTC Learn：获取 offer / answer 创建的 SDP

(2)WebRTC Learn：SDP 规范 - 会话层（全局） & 媒体层（局部）

* 会话层：会话的名称与目的；会话的存活时间；会话中包含多个媒体信息 
* 媒体层：媒体格式；传输协议；传输IP和端口；媒体负载类型

SDP格式

* 由多个`<type>=<value>` 组成
* 一个会话级描述
* 多个媒体级描述

SDP结构： `Session Description / Time Description / Meia Description`

#### 2021年04月02日 周五 14周

(1)WebRTC Learn：协议规范 WebRTC中的SDP

SDP组成: 会话元、网络描述、流描述、安全描述、服务质量

(2)WebRTC Learn：Offer_AnswerSDP

(3)WebRTC Learn：STUN_TURN服务器搭建

STUN_TURN服务器选型:

* rfc5766-turn-server
* coTurn(推荐)
* ResTurn

coTurn 服务器搭建与部署

* 下载 coTurn
* ./configure --prefix=/usr/local/coturn
* 编译 make && make install

coTurn 服务器配置

```shell
listening-port=3478 #指定监听的端口
external-ip=39.105.185.198 #指定云主机的公网IP地址
user=aaaaaa:bbbbbb #访问 stun/turn 服务的用户和密码
realm=stun.xxx.cn #域名，这个一定要设置
```

(4) RTCPeerConnection 参数

```js
//基本格式
pc = new RTCPeerConnection([configuration])
//Configuration 可选
dictionary RTCPeerConnection {
    sequence < RTCIceService > iceServers;
    RTCIceTransportPolicy iceTransportPolicy = "all";
    RTCBundlePolicy bundlePolicy = "balanced";
    RTCRtcpMuxPolicy rtcpMuxPolicy = "required";
    DOMString peerIdentity;
    sequence < RTCCertificate > certificates;
    [EnforceRange]
    octet iceCandidatePoolSize = 0;
};
```

bundlePolicy

* Balanced: 音频与视频轨使用各自的传输通道
* max-compat: 每个轨使用自己的传输通道
* max-bundle: 都绑定到同一个传输通道

certificates: 授权可以使用连接的一组证书

#### 2021年04月03日 周六 14周

(1)WebRTC Learn：直播系统中的信令及其逻辑关系

端到端信令消息：Offer 消息、Answer消息、Candidate 消息

服务端信令消息：

* joined 已加入房间
* otherjoin 其他用户加入房间
* full 房间人数已满

* leaved 已离开房间
* bye 对方离开房间

(2)WebRTC Learn：实现1:1音视频实时互动信令服务器

(3WebRTC Learn：再论CreateOffer

CreateOffer 基本格式

```js
// createOffer
aPromise = myPeerConnection.createOffer([options])
```

options 可选

`iceRestart` : 重启ICE，重新进行 Candidate 的收集

`voiceActivityDetection` : 是否开启静音检查，默认开启

#### 2021年04月04日 周日 14周

(1)WebRTC Learn：客户端状态机及处理逻辑

(2)WebRTC Learn：客户端的实现

注意要点：

* 网络连接要在音视频数据获取到之后，否则有可能绑定音视频流失败
* 当一端退出房间后，另一端的 peerConnection要关闭重建，否则与新用户互通时媒体协商会失败
* 异步事件处理

(3)WebRTC Learn：增加PeerConnecton逻辑之客户端的实现

(4)WebRTC Learn：增加媒体协商的逻辑之客户端的实现

(5)WebRTC Learn：RTPRReceiver发送器

#### 2021年04月06日 周一 15周

(1)WebRTC Learn：RTPRReceiver 发送器

RTP Media : 主要有两个类 Revier 和 Sender

* getReceivers: 获得一组 RTCRtpReceiver  对象，用于接收数据。
* getSenders: 获得一组 RTCRtpSender  对象，用于发送数据，每个对象对应一个媒体轨。

RTCRtpReceiver / RTCRtpSender 属性

| 方法             | 说明                                 |
| ---------------- | ------------------------------------ |
| MediaStreamTrack | 媒体轨                               |
| RTCDtlsTransport | Transport 媒体数据传输相关的属性     |
| RTCDtlsTransport | rtcpTransport 与 rtcp 传输相关的属性 |

RTCRtpReceiver 

| 方法                      | 说明                                  |
| ------------------------- | ------------------------------------- |
| getParameters             | 返回 RTCRtpParameter对象              |
| getSynchromizationSources | 返回一组SynchromizationSources实例    |
| getContributingSources    | 返回一组getContributingSources实例    |
| getStats                  | RTCStatsReport, 里面包括输入流统计信息 |
| getCapabilites            | 返回系统能接收的媒体能力(音频、视频)  |

(2)WebRTC Learn：RTPSender 发送器

| 方法           | 说明                                         |
| -------------- | -------------------------------------------- |
| getParameters  | 返回 RTCRtpParameter对象                     |
| setParameters  | 设置 RTP 传输相关的参数                      |
| getStats       | 提供了输出流的统计数据                       |
| replaceTrack   | 用另一个track 替换现在的 track，如切换摄像头 |
| getCapabilites | 按类型(音频、视频)返回系统发送媒体的能力     |

RTCRtpTransceiver 

* getTransceivers：从 PC 获得一组 RTCRtpTransceiver 对象，每个 RTCRtpTransceiver 是 RTPSender 和 RTCRtpReceiver对
* stop: 停止发送和接收媒体数据

(3)WebRTC Learn：传输速率的控制-1

#### 2021年04月08日 周四  15周

(1)WebRTC Learn：传输速率的控制-2

(2)WebRTC Learn：WebRTC统计信息-1

(3)WebRTC Learn：传输非音视频数据基础知识

createDataChanel

```js
//基本格式
aPromise = pc.createDataChanel(label[, options]);
//参数
label: 人类可读的字符串
options: 可选
```

Option 选项(一)

* ordered

* maxPacketLifeTime/maxRetransmits

* negotiated 

  如果为 false, 一端使用 createDataChanel创建通道，另一端监听 ondatachanel事件；如果为true，两端都可以调用 createDataChanel创建通道，通过id来标识同一个通道。

* id

使用 Options

```js
var ch = pc.createDataChannel(
    "chat", {
        negotiated: true,
        id: 0
    }
)
```

DataChannel 事件：onmessage / onopen / onclose / onerror

#### 2021年04月09日 周五 15周

(1)WebRTC Learn：端对端文本聊天

(2)WebRTC Learn：端到端文件传输

* 创建 datachannel 的时机与文本聊天一样
* 通过 js 的 FileReader 从文件中读取数据
* 以数据块为单位发送数据
* 发送数据先要将文件的基本信息以信令方式通知对方

(3)WebRTC Learn：RTP-SRTP协议头讲解 RTP/SRTP - RTCP/SRTCP - DTLS

#### 2021年04月10日 周六 15周

(1)WebRTC Learn：协议规范 RTCP中的SR与PR报文

RTCP包： UDP header ; RTCP header ; RTCP Data

①. RTCP的端口为 RTP端口(偶数) + 1；

②. 一个 RTCP 包中一般包含多个报告；

RTCP Payload Type

| PT   | 缩写 | 说明                       |
| ---- | ---- | -------------------------- |
| 200  | SR   | Send Report packet         |
| 201  | RR   | Receiver Report packet     |
| 202  | SDES | Source Description packet  |
| 203  | BYE  | Goodbye packet             |
| 204  | APP  | Application-defined packet |

Sender Info 说明

| 字段          | 说明                                   |
| ------------- | -------------------------------------- |
| NTP           | 64位，网络时间戳，用于不同源之间的同步 |
| RTP timestamp | 32位，相对时间戳，与RTP包时间戳一致    |
| packet count  | 32位，总发包数，SSRC变化时被重置       |
| octet count   | 32位，总共发送的字节数                 |

(2)WebRTC Learn：【协议规范】DTSL

(3)WebRTC Learn：wireshark 分析 rtp-rtcp 包

#### 2021年04月11日 周日 15周

(1)WebRTC Learn：Android 与 浏览器互通基本知识

* 获取权限：Camera权限 - 录制 Audio 权限 - Internet 权限
* 引入库(WebRTC、socket.io)
* 信令处理
* WebRTC处理流程

Android 权限申请

```java
//申请静态权限
<uses-permissionandroid:name="android.permission.CAMERA" />
//申请动态权限
void requestPermissions(String[] permissions,intrequestCode)
```

引入库

```java
// WebRTC
implementation 'org.webrtc:google-webrtc:1.0.+'
// socket.io
implementation 'socket:socket.io-client:1.0.0'
// easypermission
implementation 'pub.devrel:easypermission:1.1.3'
```

信令处理

客户端消息：join、leave、message（offer、answer、candidate）

服务端消息：joined、leaved、other_joined、bye、full

Andoid socket.io

发消息: `socket.emit("join",argrs);` 收消息： `socket.on("join", Listener); `

(2)WebRTC Learn：WebRTCNative开发逻辑

WebRTC处理流程：VideoCapture => Source => Track => Sink Render

#### 2021年04月12日 周一 16周

(1) WebRTC Learn：权限申请-库的引入与界面

(2) WebRTC Learn：通过socket.io实现信令收发

(3) WebRTC Learn：Andorid与浏览器互通

#### 2021年04月13日 周二 16周

(1) WebRTC Learn：iOS权限获取

(2) WebRTC Learn：iOS引入WebRTC库

* 通过 Pod 方式引入
* 编译 WebRTC 源码，手动引入

引入 WebRTC 库

* 编写 Podfile
* pod install
* open ${project}.xcworkspace

(3) WebRTC Learn：iOS端SocketIO的使用

* 通过 socket.io 连接服务端
* 发送消息
* 注册侦听的消息

#### 2021年04月14日 周三 16周

(1) WebRTC Learn：iOS界面布局

(2) WebRTC Learn：iOS端RTCPeerConnection

(3) WebRTC Learn：iOS媒体协商

(4) WebRTC Learn：iOS远端视频渲染

RTCPeerConnection 委托

* didGenerateIceCandidate
* didAddReceiver
* didOpenDataChannel

#### 2021年04月15日 周四 16周

##### 2-1 什么是数据可视化

数据可视化是一门学科；与数据和视觉有关。数据可视化简单理解就是将数据转换成易于人们辨识和理解的视觉表达形式，如各种2D图表、3D图表、地图、矢量图等等。

#### 2021年04月16日 周五 16周

##### 2-2 数据可视化发展历史

数据可视化起源于20世纪60年代诞生的计算机图形学（CG），一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。计算机图形学广泛应用于操作系统、工程制图、计算机动画、计算机游戏、虚拟现实、数据可视化。

##### 2-3 数据可视化的应用场景

简单应用：单击离线；数据量小、维度少；典型应用：Excel、Xmind、Visio、OminiGraffle；复杂应用：互联网应用；数据量大，维度多；典型应用：数据大屏、数据报表、地图、

##### 2-4 数据可视化的发展前景

成为前端工程师的标准技能；增长自身竞争力；数据可视化产品化或服务化，类似阿里云datav、腾讯云图；往其他绘图领域发展、如浏览器游戏、3D绘图、绘图工具等。

#### 2021年04月17日 周六 16周

##### 3-1 前端可视化解决方案

第四层： `Highcharts` / `Echarts` / `AntV` ；第三层： `three.js` / `zrender` / `d3`

第二层： `Canvas` / `Svg` / `WegGL` / `HTML` ；第一层： `Chrome` ；最底层： `Skia` / `OpenGL`

##### 3-2 Canvas

1. 编写 `canvas` 标签（注意指定宽高）；2. 获取 `canvas DOM` 对象；3. 获取 `Canvas ` 对象；4. 设置绘图属性；5. 调用绘图 `API`

##### 3-3 SVG 入门

SVG 是一种基于 XML 的图像文件格式，Scalable Vector Graphics，意思为可缩放的矢量图形。

#### 2021年04月19日 周一 17周

##### 3-4 webgl技术分享

`WebGL` （Web Graphics Library）是一种3D绘图协议，WebGL  可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。

##### 3-5 zrender 入门

zrender 是二维绘图引擎，它提供 Canvas、SVG、VML 等多种渲染方式，同时它也是 Echarts 的渲染器。

zrender 绘图流程：

> 1. 引入 zrender 库
>
> 2. 编写 div 容器
>
> 3. 初始化 zrender 对象
>
> 4. 初始化 zrender 绘图对象
>
> 5. 调用 zrender add 方法绘图

#### 2021年04月21日 周三 17周

##### 3-6 d3 入门

D3 (Data-Driven Documents) 是一个 JavaScript 图形库，基于 Canvas、SVG和HTML。

##### 3-7 three.js 介绍

Three.js 是一个基于 WebGL 的 JavaScript 3D 图形库。

#### 2021年04月23日 周五 17周

##### 3-9 canvas 高级应用：图片压缩算法实现(上)

##### 3-10 canvas 高级应用：图片压缩算法实现(上) 

#### 2021年04月24日 周六 17周

##### 4-1 highcharts 介绍

Highcharts 是一个用纯 JavaScript 编写的图表库，能够很简单便捷的在 web 网站或是 web 应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用。Highcharts 包含 Highcharts JS，Highstock JS，Highmaps JS 三款软件，均为纯 JavaScript 编写HTML5 的图表。

##### 4-2 antv-g2 入门

Antv G2 的绘图流程：

1. 引入 js 库
2. 编写渲染容器 DOM
3. 准备渲染数据
4. 获取渲染 DOM
5. 初始化 G2 绘图对象(如: G2Plot.Line)，配置绘图参数
6. 调用 render 完成渲染

#### 2021年04月25日 周日 17周

##### 4-3 antv-g6 入门

Antv G6 的绘图流程是怎样的？

> 1. 引入js库 2. 编写渲染容器 DOM 3. 准备渲染数据 4. 获取渲染 DOM 对象 
>
> 5. 初始化 G6 绘图对象(如：G6. Graph)，配置绘图参数 6. 调用 render 完成渲染

##### 4-4 antv-l7 入门

Antv l7 的绘图流程

> 1. 引入 js 库；2. 编写渲染容器 DOM； 3. 初始化地图对象 L7. Scene; 4. 请求数据；5. 数据清洗；
>
> 6. 初始化绘图对象(如：L7. PointLayer)；7. 调用 L7. Scene.addLayer 方法绘图

#### 2021年04月26日 周一 18周

##### 4-5 echarts 入门

Echarts 是一个使用 JavaScript 实现的开源可视库，可以流畅地运行在PC和移动设备上，兼容当前绝大部分浏览器(IE8/9/10/11，Chrome，Firefox，Safari等 )，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

##### 4-6 echarts 自定义主题和svg渲染

系列(series)是指：一组数值映射成对应的图。

#### 2021年04月27日 周二 18周

##### 4-8 echarts 新特性 dataset

Echarts 4 开始支持了数据集(dataset) 组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这一特性能将逻辑和数据分离，带来更好的复用，并易于理解。

##### 4-9 echarts 组件

ECharts 中除了绘图之外其他部分，都可抽象为「组件」。例如，ECharts 中至少有这些组件：xAxis component、yAxis component、grid component、angleAxis component、tootip  component、 legend  component、 visualMap  component、 dataZoom  component。

#### 2021年04月30日 周五 18周

##### 4-10 echarts 定位

可以采用类似 CSS absolute 的定位属性来控制组件的位置，echats 中可以通过修改 grid 组件定位来控制图表的位置。

```js
grid: {
    top: 100,
    left: '10%',
    right: '10%',
    bottom: 100,
},
```

#### 2021年05月01日 周六 18周

##### 4-11 echarts 坐标系

Echarts 基本概念：坐标系

----

很多系列，例如 line(折线图)、bar(柱状图)、scatter(散点图)、heatmap(热力图)等等，需要运行在“坐标系”上。坐标系用于布局这些图，以及显示数据的刻度等等。例如 Echarts 中至少支持这些坐标：直角坐标系、极坐标系、地理坐标系、单轴坐标系、日历坐标系等。其他系列，例如 pie(饼状图)、tree(树图)等等，并不依赖坐标系，能独立存在。还有一些图，例如 graph(关系图)等，既能独立存在，也能布局在坐标系中，依据用户的设定而来。

一个坐标系，可能由多个组件协作而成。我们以最常见的直角坐标系来举例。直角坐标系中，包括有xAxis(直角坐标系X轴)、yAxis(直角坐标系Y轴)、grid(直角坐标系底板)三种组件。xAxis、yAxis 被 grid 自动引用并组织起来，共同工作。

案例：散点图

----

最简单的使用直角坐标系的方式：只声明了 xAxis 、yAxis 和 一个 scatter(散点图标系列)，Echarts 会为它们创建 grid 并进行关联。

#### 4-12 echarts 双坐标系

当两个 yAxis，共享了一个 xAxis。两个 series，也共享了这个 xAxis，但是分别使用不同的 yAxis，使用 `yAxisIndex` 来指定它自己使用的是哪个 yAxis。

#### 4-13 echarts 多坐标系

一个 Echarts 实例中，有多个 grid，每个 grid 分别有 xAxis、yAxis，他们使用 `xAxisIndex` 、 `yAxisIndex` 、 `gridIndex` 来指定引用关系。

#### 4-14 三种技术栈对比

Echarts VS Highcharts

* Highcharts 能够兼容 IE6+，Echarts 通过 VML兼容低端浏览器
* Highcharts 文档体验略胜一筹
* Highcharts 收费，Echarts 免费
* Highcharts 基于 svg 实现，Echarts 默认采用 canvas 渲染，4.0 支持 svg 渲染
* Echarts 国内知名度更高，国内企业认可度更高

Echarts VS Antv

* Antv 文档阅读体验更符合互联网产品使用习惯
* Antv  产品体系拆分更加清晰，但一定程度上提升了学习成本
* Echarts 社区更强大，使用更加广泛

Echarts 优势总结

简单易用、文档全面、社区强大、高知名度

#### 2021年05月04日 周二 19周

##### 5-2 数据报表项目简介

创建项目：安装 vue-cli / 初始化项目 / 安装 vue-router / 安装 element-ui

静态页面开发阶段：核心指标 / 销售业绩 /  区域排名 / 分类排名 / 销售分布 / 转化率 /  热门搜索

API 联调：请求封装 / API 编写 / API 联调 /  功能测试

发布上线：域名租赁 / 服务器租赁 / Nginx 服务部署 / 自动化部署脚本 

集成 vue-element-admin: vue-element-admin 初始化 / 登录 API 联调 / 数据报表页面集成

##### 5-3 关于技术选型的说明

本项目中使用 vue 2.6 的版本，根据需要后续将升级至 3.0 版本。

##### 5-4 项目初始化

全局安装 vue/cli： `npm i -g @vue/cli@4.3.1`

创建项目 datav-report-dev: `vue create datav-report-dev`

如果安装较慢，建议使用国内的淘宝镜像：

```shell
vue create datav-report-dev --registry=https://registry.npm.taobao.org
```

启动项目

```shell
npm run serve
```

#### 2021年05月08日 周六 19周

##### 5-5 Element-UI 和 Echarts 引入

```shell
vue add element
npm i -S echarts@4.7.0
```

##### 5-6 容器组件初始化

#### 2021年05月22日 周六 21周

##### 4-12 在 Vue 中使用插槽

使用场景：当子组件的一部分内容，是根据父组件传递过来的 DOM 元素进行显示的时候。插槽只有一个，而具名插槽可以有多个，具名插槽也可以设置默认值。

```vue
<body>
  <div id="root">
    <body-content>
      <div class="header" slot="header">header</div>
      <div class="footer" slot="footer">footer</div>
    </body-content>
  </div>
  <script>
    Vue.component('body-content', {
      template: `<div>
        <slot name="header">
        <h1>default header</h1>
        </slot>
        <div class='content'>content</content>
        <slot name="footer"></slot>
      </div>`
    })
    var vm = new Vue({
      el: '#root'
    })
  </script>
</body>
```

#### 4-13 在 Vue 中使用作用于插槽

作用域插槽必须是 template 开头和结尾， `slot-scope="props"` 接收父组件传递过来的值。

```vue
<body>
  <div id="root">
    <child>
      <template slot-scope="props">
        <h1>{{props.item}} - jerry</h1>
      </template>
    </child>
  </div>
  <script>
    Vue.component('child', {
      data:function() {
        return {
          list:[1,2,3,4,5]
        }
      },
      template: `<div>
           <ul>
            <slot
              v-for = "item of list"
              :item = item
            >
              </slot>
            </ul>
        </div>
      `
    })
    var vm = new Vue({
      el: '#root'
    })
  </script>
</body>
```

#### 4-15 动态组件与 v-once 指令

```vue
<body>
  <!--动态组件-->
  <div id="root">
    <component :is="type"></component>
    <!-- <child-one v-if="type==='child-one'"></child-one>
    <child-two v-if="type==='child-two'"></child-two> -->
    <button @click="handleBtnClick">change</button>
  </div>
  <script>
    Vue.component('child-one', {
      template: `<div>child-one</div>`
    })
    Vue.component('child-two', {
      template: `<div>child-two</div>`
    })
    var vm = new Vue({
      data: {
        type: 'child-one'
      },
      el: '#root',
      methods: {
        handleBtnClick() {
          this.type = this.type === 'child-one' ? "child-two" : "child-one"
        }
      },
    })
  </script>
</body>
```

v-once 内部的内容只渲染一次。

```vue
<body>
  <div id="root" v-once>
    <!-- <component :is="type"></component> -->
  </div>
  <script>
    Vue.component('child-one', {
      template: `<div>child-one</div>`
    })
    Vue.component('child-two', {
      template: `<div>child-two</div>`
    })
    var vm = new Vue({
      data: {
        type: 'child-one'
      },
      template:`
      <div v-once>
          <child-one v-if="type==='child-one'" />
          <child-two v-if="type==='child-two'" />
          <button @click="handleBtnClick">change</button>
      </div>
      `,
      el: '#root',
      methods: {
        handleBtnClick() {
          this.type = this.type === 'child-one' ? "child-two" : "child-one"
        }
      },
    })
  </script>
</body>
```

#### 2021年05月23日 周日 21周

##### 1-1 Vue项目预热 - 环境配置

旧版 vue-cli 创建项目，Vue 2.x

```bash
# 全局安装  vue-cli
npm i -g  vue-cli
# 创建一个基于 webpack 模板的新项目
vue  init webpack travel-project
# 安装依赖
cd travel-projec
npm i
npm run dev
```

新版 vue/cli 创建项目，Vue 3.x

```bash
# 全局安装  vue-cli
npm install -g @vue/cli
npm uninstall -g @vue/cli
# 创建一个基于 webpack 模板的新项目
vue create project-travel
# 安装依赖
cd my-project
npm run serve
```

##### 1-2 Vue项目预热 - 项目环境准备（答疑）

本次项目中使用 vue 2.x，vue/cli 是 vue 3.x ，需要先卸载新版 vue/cli ，安装旧版 vue-cli

```bash
npm i -g vue-cli
```

##### 1-3 Vue项目预热 - 项目代码结构

##### 1-4 Vue项目预热 - 单文件组件与Vue中的路由（1）

路由就是根据网址的不同，返回不同的内容给用户。router-view 显示的是当前路由地址所对应的内容。

##### 1-5 Vue项目预热 - 单文件组件与Vue中的路由（2）

创建 vue 模板文件快捷键 vbase

##### 1-6 Vue项目预热 - 单页应用VS多页应

多页应用：页面跳转返回 HTML ，优点：首屏时间快，SEO 效果好；缺点：页面切换慢。

多页面指每访问一个页面，服务器对应返回一个新的html文件。

单页应用：页面跳转 JS 渲染，优点：页面切换快；缺点：首屏时间稍慢，SEO 差。

单页面应用的原理是利用js感知到url的变化, 通过js动态的将当前页面内容清除掉, 接着将下一个页面内容挂载到当前页面上。

##### 1-9  Vue项目预热 - 项目代码初始化

引入 reset.css（处理公共样式问题）, border.css （处理移动端1像素问题）。安装 fastclick 解决移动端点击300ms 延迟的问题。

```bash
npm i --save fastclick@1.0.6
```

##### 2-1 Vue项目首页 - header区域开发

```bash
npm i --save stylus@0.54.5 stylus-loader@3.0.1
```

##### 2-2 Stylus的基础语法与使用

Stylus是一个CSS预处理器（简单理解就是使用Stylus书写样式，最后转 换为CSS）。

一、Stylus 语法特点：

1、括号可由可无

```stylus
.hello
	color: red;
```

2、分号可有可无

```stylus
.hello
	color: red;
```

3、冒号可有可无（注意需要在属性和属性值之间添加空格）

```stylus
.hello
	color red
```

二、书写选择器要注意的内容

1、缩排：Stylus 的语法基于缩进，空格也有重要的意义。如下：

(1) Stylus 文件

```stylus
.box
	p
		background blue
```

(2) 编译后

```css
.box p {
    background: blue;
}
```

说明：在如上代码中，.box 与 p 标签是父子级关系，所以 p 标签的书写要在 box 的下一行添加空格。

2、规则：Stylus就跟CSS一样，允许你使用逗号为多个选择器同时定义属性，如下：

（1）Stylus文件

```stylus
textarea,input
	background blue
```

（2）编译后

```css
textarea,
input {
    background: blue;
}
```

3、父级引用：字符&指向父选择器。

如下这个例子，两个选择器(textarea和input) 在:hover伪类选择器上都改变了color值：

（1）Stylus文件

```stylus
textarea,input
 	background blue
  &:hover
    	color green
```

（2）编译后

```css
textarea,
input {
    background: blue;
}
textarea:hover,input:hover {
  color: green;
}
```

三、变量

我们可以指定表达式为变量，在大量使用该样式的时候调用该变量

（1）Stylus文件

```stylus
font-size = 50
div
  font font-size '宋体'
```

（2）编译后

```css
div {
    font: 50px '宋体';
}
```

变量甚至可以组成一个表达式列表：

（1）Stylus文件

```stylus
font-size = 50px
font-style = font-size '隶书'
div
  font font-style
```

（2）编译后

```css
div {
    font: 50px '隶书';
}
```

注意：标识符（变量名，函数等），也可能包括$字符。例如：

```stylus
$font-size = 50px
div
  font $font-size   '隶书'
```

四、方法

Stylus还可以使用一些自己定义的方法（扩展）。

（1）Stylus文件

```stylus
/*定义方法*/
add(a,b)
  a+b
div 
  /*调用方法*/
padding add(20px,30px)
```

（2）编译后

```css
div {
    padding: 50px;
}
```

五、混合书写：
混合书写和函数定义方法一致，但是应用上还是不同的。可参考如下：

（1）Stylus文件

```stylus
/*定义方法*/
error(borderWidth=2px) {
  border borderWidth solid #F00
  color #F00
}
div
  /*不传递参数调用方法*/
	error()
  p
    /*传递参数调用方法*/
	error(10px)
```

说明：这里定义了一个名叫error的方法，这个error设置了一个参数“$borderWidth”, 在没特别定义外，这个参数的值是默认值2px。

（2）编译后

```css
div {
    border: 2px solid #F00;
    color: #F00;
}

div p {
    border: 10px solid #F00;
    color: #F00;
}
```

##### 2-3 Vue项目首页 - iconfont的使用和代码优化（1）

##### 2-4 Vue项目首页 - iconfont的使用和代码优化（2）

#### 2021年05月26日 周三 22周

##### 2-5 Vue项目首页 - 首页轮播图（1）

```bash
npm install  vue-awesome-swiper@2.6.7 --save
```

```javascript
import Vue from 'vue'
import VueAwesomeSwiper from 'vue-awesome-swiper'
// import style (>= Swiper 6.x)
import 'swiper/swiper-bundle.css'
// import style (<= Swiper 5.x)
import 'swiper/css/swiper.css'
Vue.use(VueAwesomeSwiper, /* { default options with global component } */ )
```

##### 2-6 Vue项目首页 - 首页轮播图（2）

```stylus
<style lang="stylus" scoped>
# >>> 表示样式穿透
.wrapper >>> .swiper-pagination-bullet-active
    background: #fff
.wrapper
    width 100%
    overflow hidden
    height 0
    padding-bottom 55%
    bacground #eee
    .swiper-img
        width 100%
</style>
```

##### 2-7 Vue项目首页 - 图标区域页面布局

将 height 设置为0，padding-bottom 50%，overflow hidden 即可设置高宽比为50%

```stylus
<style lang="stylus" scoped>
.icons
  overflow hidden
  height 0
  padding-bottom 50%
  background green
  .icon
    width 25%
    float left
    padding-bottom 25%
    background red
</style>
```

#### 2021年05月27日 周四 22周

##### 2-8 Vue项目首页 - 图标区域逻辑实现

```javascript
 computed: {
     pages() {
         const pages = []
         this.iconList.forEach((item, index) => {
             const page = Math.floor(index / 8)
             if (!pages[page]) {
                 pages[page] = []
             }
             pages[page].push(item)
         })
         return pages
     }
 }
```

```stylus
// mixin.styl
ellipsis() {
    overflow hidden
    white-space nowrap
    text-overflow ellipsis
}
```

#### 2021年05月29日 周六 22周

##### 2-9 Vue项目首页 - 热销推荐组件开发

##### 2-10 Vue项目首页 - 开发周末游组件

可以复用 Recommand.vue 进行 Weekend.vue 的开发

##### 2-11 Vue项目首页 - 使用axios发送ajax请求

```bash
npm i axios@0.17.1 --save
```

webpack-dev-server 配置本地 mock 接口数据

```js
// vue/travel-project/config/index.js
// Paths wepack-dev-server
assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
        '/api': {
            target: 'http://localhost:8080',
            pathRewrite: {
                '^/api': '/static/mock/' // http://localhost:8080/api/index.json 代理到 /static/mock/index.json
            }
        }
    },
```

##### 2-12 Vue项目首页 - 首页父子组组件间传值

##### 1-1 Vue项目城市选择页 - 路由配置

```js
export default new Router({
    routes: [{
        path: "/",
        name: "Home",
        component: Home
    }, {
        path: "/list",
        name: "List",
        component: List
    }, {
        path: "/city",
        name: "City",
        component: City
    }]
})
```

##### 1-2 Vue项目城市选择页 - 搜索框布局

##### 1-3 Vue项目城市选择页 - 列表布局

子元素浮动，会导致父级高度塌陷，在父级中加入 overflow: hidden，可以清除浮动

#### 2021年05月31日 周一 23周

##### 1-4 Better-scroll 的使用及字母表布局

```bash
npm i better-scroll@1.8.1 --save
```

##### 1-5 better-scroll无法滚动的解决方式

在使用 better-scroll 时，可能会出现页面不能正常滚动的情况，这种现象有以下两种原因：

(1) 插件版本不同，比如 2.x 版本，比较容易出现该问题。解决方案：安装指定的 better-scroll 版本

```bash
npm i better-scroll@1.15.2 --save
```

(2) 插件实例化完成后，插件内的 HTML 结构发生了变化，导致插件实例化时的相关计算不再准确，因此无法滚动。解决方案：在 better-scroll 的 api 中，提供了 `refresh` 方法，即更新插件，作用就是解决该插件无法滚动的问题；因此可以在数据更新完成后，调用 `refresh` 方法。

```vue
export default {
	name:'CityList',
	props:{
		hot: Array,
		cities: Object,
		letter: String
	},
	mouted () {
	this.scroll = new  Bscroll(this.$refs.wrapper)
 	},
	updated () {
	this.scroll.refresh()
	}
}
```

#### 2021年06月01日 周二 23周

##### 1-6 Vue项目城市选择页 - 页面的动态数据渲染

v-for 循环对象时，(item, key) of Object，key是属性

#### 2021年06月02日 周三 23周

##### 1-7 Vue项目城市选择页 - 兄弟组件数据传递（1）

先将子组件Alphabet.vue的值传递给父组件 City.vue, 再通过父组件City.vue 传递给子组件List.vue。

另外，实现点击字母达到相应区域，可以使用 `this.scroll.scrollToElement(element)` 方法

```js
watch: {
    letter() {
        if (this.letter) {
            const element = this.$refs[this.letter][0]
            this.scroll.scrollToElement(element)
        }
    }
}
```

##### 1-8 Vue项目城市选择页 - 兄弟组件数据传递（2）

```js
computed: {
    letters() {
        const letters = []
        for (let i in this.cities) {
            letters.push(i)
        }
        // 构造数组 ["A","B","C",...]
        return letters
    }
}
```

##### 1-9 Vue项目城市选择页 - 列表性能优化

```js
methods: {
    handleLetterClick(e) {
        this.$emit("change", e.target.innerText)
    },
    handleTouchStart() {
        this.touchStatus = true
    },
    handleTouchMove(e) {
        if (this.touchStatus) {
            // 函数节流
            if (this.timer) {
                clearTimeout(this.timer)
            }
            this.timer = setTimeout(() => {
                const touchY = e.touches[0].clientY - 79
                const index = Math.floor((touchY - this.startY) / 20)
                if (index >= 0 && index < this.letters.length) {
                    this.$emit("change", this.letters[index])
                }
            }, 16)
        }
    },
    handleTouchEnd() {
        this.touchStatus = false
    }
}
```

##### 1-10 Vue项目城市选择页 - 搜索逻辑实现

```stylus
.search-content
    z-index 1
    overflow hidden
    position absolute
    top 1.58rem
    left 0
    right 0
    // bottom 0 fix:搜索结果无法滑动
```

##### 1-11 Vue项目城市选择页 - Vuex实现数据共享（1）

```bash
npm i vuex@3.0.1 --save
```

```js
import Vue from "vue"
import Vuex from "vuex"

Vue.use(Vuex)

export default new Vuex.Store({
    state: {
        city: "上海"
    }
})
// 在main.js 全局引入，使用 store 里的数据 this.$store.state.city
```

#### 2021年06月03日 周四 23周

##### 1-12 Vue项目城市选择页 - Vuex实现数据共享（2）

同步操作可通过 commit 调用 mutations 里的方法直接完成，不需要通过 actions；而异步操作 state，需要通过 调用 actions 里的 dispatch 方法完成。

编程式导航： `this.$router.push("/")` 跳转到首页

##### 1-13 Vue项目城市选择页 - Vuex的高级使用及localStorage

```js
import {
    mapState,
    mapGetters,
    mapMutations
} from "vuex"
computed: {
        ...mapState(["city"]),
        ...mapGetters(["doubleCity"])
    },
    methods: {
        handleCityClick(city) {
            // this.$store.commit("changeCity", city)
            this.changeCity(city)
            this.$router.push("/")
        },
        ...mapMutations(["changeCity"])
    },
```

##### 1-14 Vue项目城市选择页 - 使用keep-alive优化网页性能

keep-live 作用：路由被加载过一次后，就把加载后的内容放在内存中，下一次加载路由中的组件时，不需要再执行钩子函数。

##### 1-15 细节优化

```css
/*浏览器自带原生 css 处理 300ms 延迟问题*/
html {
    touch-action: manipulation
}
```

#### 2021年06月04日 周五 23周

##### 1-1 Vue项目详情页 - 动态路由和banner布局

```css
/*线性渐变色*/
background-image linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, .8))
```

##### 1-2 Vue项目详情页 - 公用图片画廊组件拆分（1）

#### 2021年06月07日 周一 24周

##### 1-3 Vue项目详情页 - 公用图片画廊组件拆分（2）

```js
// 监听到父级元素发生DOM结构的变化，自动刷新页面，解决swiper宽度计算问题
data() {
    return {
        swiperOptions: {
            pagination: ".swiper-pagination",
            paginationType: "fraction",
            observeParents: true,
            observe: true
        }
    }
},
```

##### 1-4 Vue项目详情页 - 实现Header渐隐渐显效果

```js
activated() {
        window.addEventListener("scroll", this.handleScroll)
    },
    methods: {
        handleScroll() {
            const top = document.documentElement.scrollTop
            if (top > 60) {
                let opacity = top / 140
                opacity = opacity > 1 ? 1 : opacity
                this.opacityStyle = {
                    opacity
                }
                this.showAbas = false
            } else {
                this.showAbas = true
            }
        }
    }
```

#### 2021年06月09日 周三 24周

##### 1-5 Vue项目详情页 - 对全局事件的解绑

```js
activated() {
        window.addEventListener("scroll", this.handleScroll)
    },
    deactivated() {
        // 对全局事件的解绑
        window.removeEventListener("scroll", this.handleScroll)
    },
```

##### 1-6 Vue项目详情页 - 使用递归组件实现详情页列表

递归组件就是组件调用自身的组件

```vue
<template>
  <div>
      <div v-for="(item, index) of list" :key="index" class="item">
        <div class="item-title border-bottom">
          <span class="item-title-icon"></span>{{item.title}}
        </div>
        <div class="item-children" v-if="item.children">
          <detail-list :list="item.children"></detail-list>
        </div>
      </div>
  </div>
</template>
```

#### 2021年06月10日 周四 24周

##### 1-7 Vue项目详情页 - 动态获取详情页面数据

组件中 name 有3种场景可以用到：(1) 做递归组件时可以用到；(2) 路由匹配，exclude 取消缓存时；(3) Vuex 开发工具中可以用到。

```js
// 处理滚动行为
scrollBehavior(to, from, savedPosition) {
    return {
        x: 0,
        y: 0
    }
}
```

#### 2021年06月15日 周二 25周

##### 1-8 transition

一、定义：vue 中的 transition 是一个动画过渡封装组件，常见的情景使用 transition 标签包裹的 DOM 含有动画效果。 transition 组件的动画效果过渡设置基于 css 的 transiton 属性设置。

二、使用：当页面中的 DOM 元素需要更新，移除和插入时，可使用 transition 封装组件进行动画的过渡。同时，transiton 组件可配合 CSS 类名，第三方 CSS 动画库，过渡组件的钩子函数以及第三方 JavaScript 动画库使用。

```vue
<style>
  .fade-enter-active, .fade-leave-active {transition: opacity .5s;}
  .fade-enter, .fade-leave-to {opacity: 0;}
</style>
<body>
  <div id = "demo">
    <button v-on:click="show = !show">
      Toggle
    </button>
    <transition>
    	<p v-if="show"> hello </p>
    </transition>
  </div>
  <script>
  	new Vue ({
      	el: '#demo',
          data: {
            show: true
          }
    });
  </script>
</body>
```

注意：vue 提供的 wrapper 包装的组件 -- transition，在包裹的元素中，有涉及到 v-if，v-show，动态组件，组件根节点，都会给它们添加进入/离开的过滤效果。

三、过渡的类名

进入过渡过程：v-enter, v-enter-active, v-enter-to; 离开过渡过程：v-leave, v-leave-active, v-leave-to

1.v-enter: 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。

2.v-enter-active: 定义进入过滤生效时状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

3.v-enter-to: 2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效(与此同时 v-enter 被移除)，在过渡/动画完成之后移除。

4.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。

5.v-leave-active: 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

6.v-leave-to:  2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发后下一帧生效(与此同时 v-leave 被移除)，在过渡/动画完成之后移除。

注意：默认类名是以上6个(transition 没有设置 name 属性的时候，则 v- 是这些类名的默认前缀)，如果在 transition 标签中指定了 "name=xxx"，那么6个类名将会变成 xxx 开头，例如： `<transition name="my-transition">` , 那么 v-enter 会替换为 my-transition-enter。

#### 2021年06月16日 周三 25周

##### 1-9 Vue项目详情页 - 在项目中加入基础动画

使用插槽语法

```vue
<template name="component-name">
    <transition>
        <slot></slot>
    </transition>
</template>
<script>
export default {
  name: "FadeAnimation"
}
</script>
<style lang="stylus" scoped>
    .v-enter, .v-leave-to
      opacity 0
    .v-enter-active, .v-leave-active
      transition opacity .5s
</style>
```

##### 2-1 CLI 4 升级项目

全局删除旧 vue-cli `npm uninstall vue-cli -g`

安装新版本 vue-cli `npm install @vue/cli@4.3.1 -g`

```bash
vue create travel
```

##### 2-2 入口文件迁移及 webpack 配置变更方式

##### 2-3 首页代码迁移及代理配置变更

```js
// vue.config.js
const path = require("path")

module.exports = {
    devServer: {
        proxy: {
            '/api': {
                target: 'http://localhost:8080',
                pathRewrite: {
                    '^/api': '/mock/'
                }
            }
        }
    },
    chainWebpack: (config) => {
        config.resolve.alias
            .set("styles", path.join(__dirname, "./src/assets/styles/"))
            .set("@", path.join(__dirname, "./src/"))
    }
}
```

#### 2-4 列表及详情页面迁移

#### 2021年06月19日 周六 25周

##### 6.1 completeUnitWork 整体流程和意义

根据是否中断调用不同的处理方法；判断是否有兄弟节点来执行不同的操作；完成节点之后赋值 effect 链。

##### 6-2 重设childExpirationTime

##### 6-3 completWork具体做了什么

pop 各种 context 相关的内容；对于 HostComponent 执行初始化；初始化监听事件

##### 6-4 初次渲染中completeWork对于DOM节点的创建和appendAllChild算法

updateHostComponent 

diffProperties 计算需要更新的内容；不同的 dom property 处理方式不同；

##### 6-5 初次渲染中如何进行DOM节点属性初始化操作

##### 2-3 ES6基础（1）

#### 2021年06月20日 周一 26周

##### 2-4 ES6基础（2）

* 基础指令：let/const
* 箭头函数：value => return value + 1
* 模板字符串:

```javascript
`Hello ${name} !`
```

* promise: Promise, resolve，reject， then
* 面向对象：class，extends，super，constructor
* 模块化：export，import，as，default

#### 2-5 本地存储

cookie: 用户端保存请求信息的机制；分号分隔的多个 key-value 字段；存储在本地的加密文件里；域名和路径限制

session: 服务端保存请求信息的机制；sessionId 通常存放在 cookie 里；会话由浏览器控制，会话结束，session 失效

| name     | cookie 名称       |
| -------- | ----------------- |
| domain   | cookie 生效的域名 |
| path     | cookie 生效的路径 |
| expires  | cookie 过期时间   |
| HttpOnly | 用户端不可更改    |

```javascript
document.cookie; // 查看 cookie
document.cookie = 'name=aaaaa;domain=happymmall.com;path=/index.html;expires=Mon, 21 Jun 2022 13:57:32 GMT'; // 增加 cookie
document.cookie = 'name=bbbbb;domain=happymmall.com;path=/index.html;'; // 修改 cookie
document.cookie = 'name=bbbbb;domain=happymmall.com;path=/index.html;expires=Mon, 21 Jun 2020 13:57:32 GMT'; // 将过期时间设置为过去的时间或0
```

localStorage: H5 新特性；有域名限制，不存在作用域概念；只有 key-value； 没有过期时间；浏览器关闭后不消失

sessionStorage: 和 localStorage 极其相似；浏览器关闭后消失

```javascript
// 添加 localStorage
window.localStorage.setItem('name', 'Rosen');
window.localStorage.setItem('aaa', JSON.stringify({
    name: "Rosen"
}))
// 查看 localStorage
window.localStorage.getItem('name');
// 删除 localStorage
window.localStorage.removeItem('name')

// 添加 sessionStorage
window.sessionStorage.setItem('name', 'Rosen');
window.sessionStorage.setItem('aaa', JSON.stringify({
    name: "Rosen"
}))
// 查看 sessionStorage
window.sessionStorage.getItem('name');
// 删除 sessionStorage
window.sessionStorage.removeItem('name')
```

##### 3-1 前端框架分析

##### 3-2 前端框架要解决的问题

|          | 原生开发             | 框架开发             |
| -------- | -------------------- | -------------------- |
| 代码层面 | 缺少规划，代码混乱   | 结构化开发           |
| 代码层面 | 缺少限制，容易冲突   | 对立文件，对立作用域 |
| 代码层面 | 缺少支撑，能力要求高 | 提供支持，只关注业务 |
| 效率问题 | 关注所有流程         | 关注业务             |
| 效率问题 | 团队效率低           | 并行开发             |
| 效率问题 | 测试效率低           | 模块测试，自动化测试 |
| 多页应用 | 路由体验问题         | 使用单页路由         |
| 多页应用 | 无页面切换效果       | 可以添加过场动画     |
| 多页应用 | 浪费服务器资源       | 减少服务器资源       |

##### 3-3 三大框架对比

Angular: 2009年发布，Google 收购；主要版本：1.x，2.x，3.x，4.x，5.x ； 基于 html 的大而全的 MVC 框架

React: 2013年5月开源，Facebook；主要版本：16.x；基于 JS 的视图层框架；

Vue.js: 2014年2月开源，尤雨溪，先加入阿里 Weex 团队；主要版本：0.1x，1.x， 2.x；基于 html  的视图层框架；

|          | Angular  | React    | Vue      |
| -------- | -------- | -------- | -------- |
| 组织方式 | MVC      | 模块化   | 模块化   |
| 数据绑定 | 双向绑定 | 单向绑定 | 双向绑定 |
| 模板能力 | 强大     | 自由     | 简洁     |
| 路由     | 静态路由 | 动态路由 | 动态路由 |

#### 2021年08月09日 周一 32周

今日起回归 imooc 课程日常学习，增加实践操作。

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 6-7 completeWork阶段对于HostText的更新

###### 6-8 renderRoot 中对错误的处理

##### 课程2: React16+React-Router4 从零打造企业级电商后台管理系统

###### 4-1 开发环境的搭建

git => gitee.com webpack => yarn nodejs node-sass

* webpack 的安装和配置
* 系统里多个版本 webpack 项目共存的处理
* webpack 对各种类型文件的处理方式
* webpack-dev-server 的安装和配置

##### 4-2 git 的安装和项目的建立

.gitconfig 的配置，注意 `=` 两边尽量不要加空格，查看 git 版本 `git --version`

```bash
vim ~/.gitconfig
[user] 
	name = jerrychane
	email = jerrychane@126.com
[alias]
	co  = checkout
	cm = commit
	st=status
	pl =pull
	ps = push
	dt = difftool
	ca = commit -am
	br = branch
```

* 生成 ssh 公钥：`ssh-keygen -t rsa -C 'jerrychane@126.com'`

* gitee.com 创建 git 项目，添加个人公钥，git clone 项目到本地
* 配置本地项目 .gitignore

#### 2021.08.11 WED 32WEEK BJ

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 6-9 unwindWork以及React中的错误处理

* 类似 completeWork 对不同类型组件进行处理
* 对于 ShouldCapture 组件设置 DidCapture 副作用

###### 7-1 commitRoot的总体工作内容

###### 7-2 invokeGuardedCallback开发时的帮助方法

##### 课程2: React16+React-Router4 从零打造企业级电商后台管理系统

###### 4-3 nodejs 和 yarn 的安装

yarn : 包管理工具，替代 npm ; 安装速度快，版本锁定，缓存机制

安装命令： `npm install yarn -g`

| Yarn                      | Npm                              |
| :------------------------ | :------------------------------- |
| yarn init                 | npm init                         |
| yarn                      | npm install                      |
| yarn global add xxx@x.x.x | npm install xxx@x.x.x -g         |
| yarn add xxx@x.x.x        | npm install xxx@x.x.x --save     |
| yarn add xxx@x.x.x --dev  | npm install xxx@x.x.x --save-dev |
| yarn remove xxx           | npm uninstall xxx --save(-dev)   |
| yarn run xxx              | npm run xxx                      |

##### 4-4  webpack 配置(1)

* 一个前端资源加载/打包工具；
* 使用版本为 3.10.0 ，`yarn add webpack@3.10.0 -dev` ; 
* 多版本 webpack 共存解决方案

需要处理的文件类型：

| HTML      | html-webpack-plugin        |
| --------- | -------------------------- |
| 脚本      | babel + babel-preset-react |
| 样式      | css-loader + sass-loader   |
| 图片/字体 | url-loader + file-loader   |

webpack 常用模块

* html-webpack-plugin, html 单独打包成文件
* extract-text-webpack-plugin, 样式打包成单独文件
* CommonsChunkPlugin, 提取通用模块

webpack-dev-server  更改代码自动刷新 + 路径转发

```bash
yarn add webpack-dev-server@2.9.7 --dev
```

```
yarn add webpack@3.10.0 --dev
yarn add html-webpack-plugin@2.30.1 --dev
yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev
yarn add babel-preset-react@6.24.1 --dev
yarn add react@16.2.0 react-dom@16.2.0
# 处理 css
yarn add style-loader@0.19.1 css-loader@0.28.8 --dev
yarn add extract-text-webpack-plugin@3.0.2 --dev
# 处理 scss
yarn add sass-loader@6.0.6 --dev
yarn add node-sass@^4.7.2 --dev
```

全局没有安装 webpack 时，可执行以下命令打包 `node_modules/.bin/webpack`

#### 2021.08.16 MON 33WEEK BJ

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 7-2 invokeGuardedCallback开发时的帮助方法

###### 7-3 commitRoot第一个操作-获取快照

##### 课程2: React16+React-Router4 从零打造企业级电商后台管理系统

###### 4-5  webpack 配置(2)

```bash
# url-loader 依赖 file-loader
yarn add file-loader@1.1.6 url-loader@0.6.2 --dev
# 处理字体
yarn add font-awesome@4.7.0
# devServer
yarn add webpack-dev-server@2.9.7 --dev
# 访问url
http://localhost:8080/dist/index.html
```

```bash
yarn run dev
yarn run dist
```

###### 4-6 代码提交

* 从 master 切换到开发分支上
* git merge origin master, 拉取远程仓库最新的代码
* git add . ， 追踪文件的变化
* git commit -am "备注信息"，将代码提交到本地仓库
* git push, 本地仓库代码推送到远程仓库
* 提交 pull request，管理员审核

#### 2021.08.17 tue 33week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 7-4 commitAllHostEffects 总体做了哪些事情

###### 7-5 commitPlacement插入新的子节点的操作

###### 7-6 commitWork更新节点属性的过程

#### 2021.08.18 wed 33week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 7-7 commitWork删除节点的操作过程

遍历子树 & 卸载 ref & 如果有组件则调用 componentWillUnmount 方法

###### 7-8 commitLifecycles调用生命周期方法

###### 8-1 context-stack

* 更新节点时相关信息入栈
* 完成节点时相关信息出栈
* 用不同的 cursor 记录不同的信息

###### 8-2 遗留context-api的实现过程（1）

LegacyContext  react 17 会移除，原因：1. 会影响整个子树；2. 嵌套的 context 提供者需要进行合并；3. 对性能的影响比较大

###### 8-3 遗留context-api的实现过程（2）

###### 8-4 新context的实现

* 组件化的使用方式
* context 的提供方和订阅方都是独立的
* 没什么附带的性能影响

#### 2021.08.19 thu 33week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 8-5 ref 的实现过程

* 创建 Fiber 的时候处理 ref && commit 开始先 detach

###### 8-6 hydrate-是否需要hydrate的判断

###### 8-7 hydrate-更新开始判断节点是否可以hydrate

###### 8-8 hydrate-再completeWork中复用可hydrate的节点

#### 2021.08.20 fri 33week bj

UML 图专业术语
| EN                           | CN          | SCENE                                                      |
| ---------------------------- | ----------- | ---------------------------------------------------------- |
| Class Diagram                | 类图        | 类名(Class)+属性(Attributes)+操作(Operations)              |
| Pakage Diagram               | 包图        | Package可以理解为文件夹(folder)                            |
| Object Diagram               | 对象图      | 对象的名称和对象的属性                                     |
| Composite Structure Diagram  | 组合结构图  | 显示组合结构或部分系统的内部构造                           |
| Component Diagram            | 组件图      | 描述件组件以及组件之间的关系。                             |
| Deployment Diagram           | 部署图      | 实体（Artifact）+ 部署目标（Deployment target）            |
| Use Case Diagram             | 用例图      | 述角色以及角色与用例之间的连接关系                         |
| Sequence Diagram             | 时序图      | 描述对象之间发送消息的时间顺序                             |
| Comunication Diagram         | 协作图      | 参加交互的各对象结构的信息                                 |
| Timing Diagram               | 计时图      | 沿时间线更改的消息或条件的计时或持续时间                   |
| Interaction Overview Diagram | 交互概述图  | 整体上概览交互过程中的控制流，包括交互图之间的事件或消息流 |
| Information Flow Diagram     | 信息流图    | 描述高度抽象的系统实体之间的信息交换                       |
| Statechart Diagram           | 状态图      | 描述一个实体基于事件反应的动态行为                         |
| Activity Diagram             | 活动图      | 某件事情正在进行的状态                                     |
| Profile Diagram              | 总则图      | 描述专有建模的元素，描述扩展机制                           |
| Requirement Diagram          | 需求图      | 创建需求和描述需求                                         |
| Block Definition Diagram     | 模块定义图  | 对系统的结构组成以及组成元素间的关系进行描述               |
| ER Diagram                   | 实体-联系图 | 描述现实世界关系概念模型的有效方法                         |
| Flowchart Diagram            | 流程图      | 描述工作流和进程的图                                       |
| Data Flow Diagram            | 数据流图    | 描绘数据在系统中流动和处理的过程                           |

#### 2021.08.23 mon 35week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 8-9 event事件系统初始化-注入平台事件插件

* 确定插件注入顺序 -> 注入插入模块 -> 计算 registrationNameModules 等属性

克隆一个数组：

```js
const cloneArr = Array.prototype.slice.call(arr);
```

###### 8-10 event 事件监听的过程

###### 8-11 event-事件触发的过程

###### 8-12 event-事件对象的生产过程

###### 8-12 event查漏补缺

#### 2021.08.25 wed 35week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 9-1 优先级和任务挂起的含义(1)

什么叫 `Suspand` : 字面意思是挂起，某次更新的任务暂时不提交；这个更新可能在下一次更新中再次被执行。

###### 9-2 优先级和任务挂起的含义（2）

三种 `Suspend` 方式：把提交放到低优先级的任务上；直接发起一个新的同步更新；设置 timeout 然后提交。

类型： `pendingTime` / `suspendedTime` / `pendedTime`

###### 9-3 两个expirationTime的不同作用

`expirationTime` 作用于再渲染前； `nextExpirationTimeToWorkOn` 作用再渲染时。

###### 9-4 Suspense组件同步模式下的更新

同步渲染: 先直接渲染子节点为 `null` , `commit ` 的时候设置 `state` ， 再发起一次同步更新渲染 `fallback`

###### 9-5 Suspense组件同步渲染模式补充

#### 2021.08.26 thu 35week bj

##### 课程1: React源码深度解析 高级前端工程师必备技能

###### 9-7 retrySuspendedWork 所做的事情

###### 10-1 什么是 Hooks 以及其逻辑

赋予函数组件类组件的能力，主要用到的 `hook` 方法有 `useState` / `useEffect` / `useContext` / `useReducer` / `useLayoutEffect` / `useCallBack` / `useMemo` / `useRef` / `useImperativeHandle`

###### 10-3 useState 的实现原理和注意事项（1）

###### 10-4 useState 的实现原理和注意事项（2）

###### 10-5 useEffect和useLayoutEffect的实现原理和区别

课程总结：`React` 的存粹

- 一切基于 `State`

#### 2021.08.27 fri 35week bj

##### 课程1: 支付宝小程序入门与实战 开发高颜值电商项目

###### 1-2 课程导学

技术学习：掌握蚂蚁开发者工具基本操作；熟悉基础组件与`api`; 掌握 `flex` 布局与`rpx` 自适应； 掌握模板与自定义组件。

（基础语法 => 声明周期 => 模板与组件 => 动画实现）

实战部分：在线接口文档、随堂笔记；学习小程序编程思路；购物业务、订单业务、支付业务；掌握前后端联调；真机调试、授权登录/收银台支付，讲解发布上线。

（项目搭建 => 统一样式风格 => 统一接口规范=> 本地开发=> 线上接口线下本地联调=> 支付宝授权登录、支付宝收银台登录=> 真机测试=> 发布上线）

#### 2021.08.28 sat 35week bj

###### 2-1 创建小程序，申请appId，设置团队开发者

- 注册流程，appId 获取，设置团队开发者
- 初始蚂蚁开发者工具
- 构建你的第一款电商小程序
- 四种基本类型文件

支付宝小程序官方网站：https://mini.open.alipay.com/

##### 2-2 开发环境搭建&开发者工具介绍

小程序开发者工具： https://render.alipay.com/p/f/fd-jwq8nu2a/pages/home/index.html

- 项目新建、打开；布局调整和默认设置；
- 自定义布局：文件目录树、模拟器、调式器
- 开发者界面：编码、真机调试、测试报告、上传审核

##### 2-3 开发第一个支付宝小程序hello world

在小程序中没有 `<div>` 标签，代替的是`<view>` 标签

##### 2-4 四种基本文件类型与page样式

- html -> axml
- css -> acss
- js
- json(配置文件)

##### 3-1 app的三种文件类型与路径配置管理

- app.js(必) 全局脚本、全局常量
- app.acss(选) 全局样式
- app.json(必) 项目配置

页面路径配置

- 对象结构

```json
{
  "pages" :[
    "pages/index/index",
    "pages/hello/hello"
  ]
}
```

#### 2021.08.29 sun 35week bj

##### 3-2 结合生活实例讲解与演示app生命周期

- `onLauch` 项目初始化完成时触发，只触发一次
- `onShow` 页面展示的时候触发
- `onHide` 页面隐藏的时候触发
- `onError` 页面出现错误的时候触发

##### 3-3 页面的生命周期 - 上

- `onLoad` 页面加载时执行，每个页面只执行一次
- `onReady` 页面初次渲染完成时执行，每个页面只执行一次
- `onShow` 页面显示后执行一次，可执行多次
- `onHide` 页面每次隐藏时执行一次
- `onUnload` 页面卸载执行一次

##### 3-4 页面的生命周期 - 下

- `onTitleClick` 标题被点击后执行，可执行多次
- `onReachBottom` 页面触底时执行，可执行多次
- `onPullDownRefresh`  下拉刷新，注意要在对应 `json` 文件中开启下拉刷新 `"pullRefresh": true`
- `onShareAppMessage` 点击分享按钮时执行，需要写成一个对象

```js
onShareAppMessage() {
    console.log("Page onShareAppMessage");
    return {
      title: "hello world",
      desc: "this is a describe content",
      path: "pages/hello/hello"
    }
  }
```

##### 3-5 全局常量、对象、自定义函数的使用

- `getApp()` `app` 对象，外部脚本操作`app` 中的对象、方法、常量

#### 2021.08.30 mon 36week bj

##### 3-6 全局样式的使用和重写

- `app.acss`  自定义样式，page.acss 自动引入，可以被重写; 当没有私有样式时，会去全局寻找对应的样式，全局和私有相当于父子继承关系。

##### 3-7 全局与私有标题栏的配置 `App.json`

```json
{
  "pages": [
    "pages/hello/hello",
    "pages/index/index"
  ],
  "window": {
    "defaultTitle": "慕课购物",
    "titleBarColor": "#ffbfc7"
  }
}
```

##### 3-8 tab选项卡介绍与模块页面的创建

导航栏 - items tab 项数组配置： 首页 - 分类 - 购物车 - 我的

##### 3-9 tab 选项卡的配置与显示

- `textColor`  文字颜色
- `selectedColor`  文字选中后颜色
- `backgroundColor`  背景颜色
- `items`  每个单独 tab 项(数组)

每个 item 项的配置如下：

* `pagePath`  页面路径
* `name`  文字
* `icon`  未选中的图标
* `activeIcon`  选中后的图标

```json
"tabBar":{
  "textColor":"字体颜色",
  "selectedColor":"选中颜色",
  "backgroundColor":"底色",
  "items":[{
    "pagePath":"pages/index/index",
    "name":"首页",
    "icon":"未选中的图标",
    "activeIcon":"选中后的图标"
  }]
}
```

#### 2021.08.31tue 36week bj

##### 3-10 导航组件页面跳转 `<navigator></navigator>`

- `hover-class `点击时改变的样式
- `hover-start-time`按住多少 ms 后出现点击状态
- `hover-stay-time ` 手指释放多少 ms 后保留的状态
- `url ` 跳转地址
- `open-type ` 跳转类型，默认值是 `navigate` 保留当前页面，跳转新页面；`redirect` 销毁当前页面，跳转新页面；`navigateBack`  返回到上一级页面，只作用于 `navigate` 属性下；`switchTab`  跳转到 tabBar 页面

##### 3-11 导航 api 与章节回顾

- `my.navigateTo()`
- `my.redirectTo()`
- `my.navigateBack()`
- `my.switchTab()`

##### 4-1 flex 布局的概念与模型

* 理解`flex` 布局的概念、优势、术语、模型
* 容器的六大属性和布局设置
* 元素的六大属性
* `flex` 布局练习

##### 4-2 flex-direction 水平轴与交叉轴的排列方向

Flex 容器的属性

- `flex-direction` : 容器内元素的排列方向，`row(默认值)/row-reverse/column/column-reverse`

#### 2021.09.01 wed 36week bj

##### 4-3 flex-warp 换行属性以及flex-flow的结合

- `flex-wrap` : 元素换行，`nowrap(默认值)/wrap/wrap-reverse`

`nowrap` 会压缩元素的宽度，而`wrap/wrap-reverse` 则不会

- `flex-flow:flex-direction` 和 `flex-wrap` 的结合

  `flex-flow:[flex-direction] [flex-wrap]`

##### 4-4 justify-content在水平轴与交叉轴的对齐方式

`justify-content:flex-start/flex-end/center/space-between/space-around/space-evenly`

`space-between` : 元素与元素之间的间隙相同

`space-around` :  元素与容器的间隙相同

`space-evenly` : 元素与元素之间，元素与容器的间隙相同

##### 4-5 align-items元素在交叉轴的对齐方式

`align-items` : 每个元素在交叉轴上的对齐方式，`flex-start/flex-end/center/baseline/stretch(默认值)`

`baseline` : 元素内的文字在同一条基线上对齐；`stretch` : 当元素本身没有设置高度，则拉伸到整个容器

##### 4-6 align-content基于多轴线的对其方式

`align-content` : 多轴线的对齐方式（把每个轴线视为元素，至少要有两行），`flex-start/flex-end/center/stretch/space-between/space-around`

#### 2021.09.02 thu 36week bj

##### 4-7 flex设置元素的排序、拉伸与缩放

- `order`: 元素的顺序，默认值是 0，数值越小，排列越靠前
- `flex-grow`: 元素的所占比例大小，扩充
- `flex-shrink`: 缩小比例

##### 4-8 flex设置元素的固定占比与重写对齐方式

- `flex-basis` : 固定或自动空间的占比，优先级比 `width` 高，会覆盖 `width`
- `flex:[flex-grow] [flex-shrink][flex-basis] ` 合并写法
- `align-self`: 可重写 `align-items` 父元素的属性

#### 4-9 模拟骰子1点数进行flex布局演练

- `flex`  实现骰子(色)子

##### 4-10 模拟骰子2点数进行flex布局演练

##### 4-11 模拟骰子3点数进行flex布局演练

##### 4-12 模拟骰子4-6点数进行flex布局演练

```css
page {
  display: flex;
  justify-content: center;
  align-items: center;
}
.container {
  width: 300px;
  height: 300px;
  background-color: #c9394a;
  border-radius: 20px;
  display: flex;
  flex-wrap: wrap;
  align-content: space-between;
  padding: 30px;
}
.row1 {
  width: 50%;
  display: flex;
  justify-content: flex-start;
}
.row2 {
  width: 50%;
  display: flex;
  justify-content: flex-end;
}
.row3 {
  width: 50%;
  display: flex;
  justify-content: flex-start;
}
.row4 {
  width: 50%;
  display: flex;
  justify-content: flex-end;
}
.point {
  width: 100px;
  height: 100px;
  background-color: #fff;
  border-radius: 50px;
}
```

##### 5-1 数据绑定与渲染

- 数据绑定：条件判断、列表渲染
- 事件：事件类型与`dataset` 自定义数据
- 样式：固定像素`px` 与自适应像素 `rpx`

数据绑定：通过 `{{value}}` 表达式来动态的渲染页面的内容; 数据需要写入每一个 `page` 中的 `data` 对象

```js
<view>hello {{username}}</view>
data: {
  username: "jerrychane"
}
```

##### 5-2 ifelse条件渲染

- 通过数据绑定传入`true` 或者 `false`

```js
<view a:if="{{flag}}"></view>
```

- 这个布尔值可以写进 `data`

```js
data: {
  flag: true
}
```

- 可通过运算结果后进行判断

```js
<view a:if="{{age<18}}"> 未成年 </view>
<view a:elif="{{age>=18 && age <60}}"> 成年</view>
<view a:else> 老年 </view>


<view hidden="{{true}}" class="demo-words">
  隐藏
</view>

<view hidden="{{false}}" class="demo-words">
  显示
</view>

<view hidden="{{student.score >=60 ? true : false }}" class="demo-words">
  不合格
</view>
```

#### 2021.09.03 fri 36week bj

##### 5-3 for循环列表渲染

- 通过`data` 中的数组绑定后在页面中进行循环展示

```xml
data: {
  stu: ['Tom', 'Json', 'Jack',]
}
// 自定义列表显示
<view a:for='{{stu}}' a:for-item='item' a:for-index='index'>{{index}}:{{item}}</view>
```

##### 5-4 view与block的区别

条件判断: `view` 标签可见，`block` 标签不可见

```xml
<view a:if="{{flag}}"></view>
<block a:if="{{flag}}"></block> 
```

列表循环：

```xml
<view a:for='{{stu}}'>{{index}}:{{item}}</view>
<block a:for='{{stu}}'>{{index}}:{{item}}</block>
```

`block` 标签只会显示 `block` 标签体内具体的内容，外层所包的作用体不会显示

##### 5-5 6种不同的事件类型

- `tap` 与 `longTap` 触摸，类似 PC 端的`click`
- `touchStart` 与 `touchMove`
- `touchEnd` 与 `touchCancel`

#### 2021.09.04 sat 36week bj

##### 5-6 dataset自定义数据的使用

```xml
<view data-name="1" data-age="2" onTap="tap">测试 dataset</view>
```

```js
tap: function(e) {
  console.log(e.target.dataset.name);
  console.log(e.target.dataset.age);
}
```

##### 5-7 使用rpx响应式像素实现自适应拉伸

- `*.acss `即 `web` 中的 `*.css`
- `web` 开发中怎么用，小程序里也怎么用
- 全局样式 - 页面(局部)样式 - 组件样式
- 不得写 `.a- `与 `.am- `开头的 `class`,已被系统占用

- `rpx`: 自适应(响应式)像素

| 设备     | 换算(屏幕宽度/750) | 换算(750/屏幕宽度) |
| -------- | ------------------ | ------------------ |
| iPhone5  | 1rpx = 0.42px      | 1px = 2.34rpx      |
| iPhone6  | 1rpx = 0.5px       | 1px = 2rpx         |
| iPhone6P | 1rpx = 0.552px     | 1px = 1.81px       |

```css
.block {
  /* 以 iPhone6 为例，iPhone6 的固定宽度未 375px */
  /* width: 375px;
  height: 375px; */
  /* 自适应，自动拉伸或者扩展，形成一个自适应的正方形 */
  width: 750rpx;
  height: 750rpx;
  background-color: #c9394a;
}
```

##### 6-1 图片组件的使用

- 使用标签

  ```xml
  <image src="" class="" style="" mode="" lazyLoad="" onError="" onLoad="" />
  ```

##### 6-2 图片的4种缩放模式与9种裁剪模式讲解

- `mode` 图片缩放模式
  - `scaleToFill`  图片的宽高完全拉伸至填满 `image` 元素
  - `aspectFit` 保持宽高纵横比缩放，保证图片长的一边完全显示
  - `aspectFill` 保持宽高纵横比缩放，保证图片短的一边完全显示
  - `widthFix` 宽度不变，高度自动变化，保持原图宽高比不变
- `mode` 图片裁剪模式

  - `top`  不缩放图片，只显示顶部区域
  - `bottom` 不缩放图片，只显示底部区域
  - `center`不缩放图片，只显示中间区域
  - `left` 不缩放图片，只显示左边区域
  - `right `不缩放图片，只显示右边区域
  - `top left`  不缩放图片，只显示左上边区域
  - `top right` 不缩放图片，只显示右上边区域
  - `bottom left`不缩放图片，只显示左下边区域
  - `bottom right` 不缩放图片，只显示右下边区域

##### 6-3 轮播图组件的使用与属性讲解

```xml
<swiper
        indicator-dots = ""   // 是否显示指示点
        indicator-color=""  // 指示点颜色
        indicator-active-color=""  // 当前选中指示点颜色
        style=""
        autoplay="{{false}}" // 自动播放
        current="0"  // 设置当前页面的 index
        duration="500" // 滑动过程动画时长
        interval="5000" // 自动切换间隔时长
        circular="{{false}}"  // 是否启用无限滑动
        vertical="{{false}}" // 滑动方向是否为纵向
        onChange=""  // current 改变时触发
        >
	<swiper-item><image/></swiper-item>
</swiper>
```

Demo

```xml
<swiper indicator-dots="{{true}}" 
  indicator-color="yellow"  
  indicator-active-color="red"  
  style="" 
  autoplay="{{true}}" 
  current="1"    
  duration="500" 
  interval="5000" 
  circular="{{false}}"  
  vertical="{{false}}" 
  onChange="" 
  >
  <swiper-item >
    <image class="img" src="//img1.mukewang.com/61302fff0001e3d217920764.jpg" />
  </swiper-item>
  <swiper-item >
    <image class="img" src="//img1.mukewang.com/612d869300019d4217920764.jpg" />
  </swiper-item>
  <swiper-item >
    <image class="img" src="//img1.mukewang.com/612d8acc0001e48017920764.jpg" />
  </swiper-item>
</swiper>
```

#### 2021.09.05 sun 36week bj

##### 6-4 scroll-view组件的使用

- `scroll-view` 组件

  ```xml
  <scroll-view scroll-x="" scroll-y=""></scroll-view>
  ```

##### 6-5 开发首页轮播图

- 轮播图-横向滑动推荐商品-纵向新品列表

```xml
<!-- 轮播图 -->
<swiper indicator-dots="{{true}}" indicator-active-color="#ff6699" autoplay="{{true}}">
    <swiper-item >
        <image mode="scaleToFill" src="/resources/img/1.png" class="swiper-item-img"/>
    </swiper-item>
     <swiper-item >
        <image mode="scaleToFill" src="/resources/img/4.png" class="swiper-item-img"/>
    </swiper-item>
</swiper>
```

##### 6-6 flex二级嵌套开发商城特色一栏

```xml
<!-- 商城特色 -->
<view class="feature">
  <view>
    <image mode="scaleToFill" src="/resources/icon/smallIco/fang.png" class="feature-ico" />
    全场包邮
  </view>
  <view>
    <image mode="scaleToFill" src="/resources/icon/smallIco/flash.png" class="feature-ico" />
    先行赔付
  </view>
  <view>
    <image mode="scaleToFill" src="/resources/icon/smallIco/yuan.png" class="feature-ico" />
    7天无理由退款
  </view>
  <view>
    <image mode="scaleToFill" src="/resources/icon/smallIco/ling.png" class="feature-ico" />
    优先退款
  </view>
</view>
```

##### 6-7 可滚动视图组件开发推荐商品

```xml
<!-- 推荐商品 -->
<view class="title-item-list">
  <view class="title-tag">
    <image mode="scaleToFill" src="/resources/icon/smallIco/rec.png" class="title-ico" />
    推荐商品
  </view>
</view>
<!-- 推荐商品列表 -->
<scroll-view class="scroll-rec-items" scroll-x="{{true}}">
  <image mode="scaleToFill" src="/resources/items/1001.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1002.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1001.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1002.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1001.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1002.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1001.png" class="items-cover" />
  <image mode="scaleToFill" src="/resources/items/1002.png" class="items-cover" />
</scroll-view>
```

##### 6-8 完成纵向新品列表

```xml
<!-- 商品上新列表 -->
<view class="title-item-list">
  <view class="title-tag">
    <image mode="scaleToFill" src="/resources/icon/smallIco/diamond.png" class="title-ico" />
    商品上新
  </view>
</view>
<view class="new-item-list">
  <view class="item-outer">
    <image mode="scaleToFill" src="/resources/items/1002.png" class="new-item-cover" />
    <view class="item-border">
      <view class="tags">
        衣服
      </view>
       <view class="tags">
        裤子
      </view>
       <view class="tags">
        奢侈品
      </view>
       <view class="tags">
        衣服
      </view>
       <view class="tags">
        裤子
      </view>
       <view class="tags">
        奢侈品
      </view>
    </view>
    <view class="price-border">
      <view class="price">
        ￥100.00
      </view>
       <view class="like-counts">
         888
         <image mode="scaleToFill" src="/resources/icon/smallIco/likes.png" class="like-ico" />
      </view>
    </view>
  </view>
</view>
```

##### 6-9 发送httpRequest获取轮播图数据

网络请求-API

```js
my.httpRequest({
  url: 'http://serverurl',
  method: 'POST',
  header: {'content-type': 'application/json'},
  data: {name:'jack', age: '18'},
  dataType: 'json',
  success: function(res) {},
  fail: function(res) {},
   complete: function(res) {}
})
```

```js
  onShow() {
    // 页面显示
    // 请求轮播图
    my.httpRequest({
      url: app.serverUrl + '/index/carousels',
      method: 'POST',
      header: { 'content-type': 'application/json' },
      // data: {name:'jack', age: '18'},
      dataType: 'json',
      success: function (res) {
        console.log(res);
      },
      fail: function (res) {
        console.log('发生错误' + res);
      },
      complete: function (res) {
        console.log('最终执行的 complete' + res);
      }
    })
  },
```

##### 6-10 首页轮播图动态渲染

```js
const app = getApp();

Page({
  data: {
    carousels: []
  },
  onShow() {
    var self = this;
    // 页面显示
    // 请求轮播图
    my.httpRequest({
      url: app.serverUrl + '/index/carousels',
      method: 'POST',
      header: { 'content-type': 'application/json' },
      // data: {name:'jack', age: '18'},
      dataType: 'json',
      success: function (res) {
        console.log(res);
        // 获取后端返回的数据
        var myData = res.data;
        if (myData.status === 200) {
          var carousels = myData.data;
          self.setData({
            carousels
          })
        }

      },
      fail: function (res) {
        console.log('发生错误' + res);
      },
      complete: function (res) {
        console.log('最终执行的 complete' + res);
      }
    })
  },
});

```

```xml
<!-- 动态获取轮播图 -->
<swiper indicator-dots="{{true}}" indicator-active-color="#ff6699" autoplay="{{true}}" style="400rpx">
  <block a:for="{{carousels}}" a:for-item="pic">
    <swiper-item >
      <image mode="scaleToFill" src="{{pic.imageUrl}}" class="swiper-item-img" />
    </swiper-item>
  </block>
</swiper>
```

#### 2021.09.08 wed 37week bj

##### 6-11 网络请求获取推荐商品以及新品列表数据

```js
// index item 
    // 请求推荐商品列表
    my.httpRequest({
      url: app.serverUrl + '/index/items/rec',
      method: 'POST',
      header: { 'content-type': 'application/json' },
      dataType: 'json',
      success: function (res) {
        // 获取后端返回的数据
        console.log("rec:",res.data)
        var myData = res.data;
        if (myData.status === 200) {
          var featureList = myData.data;
          self.setData({
            featureList
          })
        }

      }
    })
    // 请求新品列表
    my.httpRequest({
      url: app.serverUrl + '/index/items/new',
      method: 'POST',
      header: { 'content-type': 'application/json' },
      dataType: 'json',
      success: function (res) {
        // 获取后端返回的数据
        console.log("new:",res.data)
        var myData = res.data;
        if (myData.status === 200) {
          var newItemList = myData.data;
          self.setData({
            newItemList
          })
        }

      }
    })
```

##### 6-12 推荐商品以及新品列表数据渲染展示

#### 2021.09.09 thu 37week bj

##### 6-13 下拉实现首页数据刷新

- 页面配置 `pullRefresh: true`
- 使用页面生命周期函数 `onPullDownRefresh`

##### 7-1 开发分类页面 - 固定搜索栏

- 搜索栏可以输入具体的商品名称，进行搜索
- 分类展示，点击某一个分类，则显示该分类下的所有商品列表
- 以上两个功能点的最终查询结果跳转到商品列表页面

```xml
<!-- 搜索栏 -->
<view class="search">
    <form class="search-form">
        <image class="search-icon" mode="scaleToFill" src="/resources/icon/smallIco/search.png" />
        <input class="search-input" placeholder="请输入搜索商品名..." type="text" auto-focus confirm-type="search" onConfirm="" />
    </form>
</view>
```

##### 7-2 开发分类页面 - 显示每一个分类元素

```xml
<view class="category">
    <view class="cat-item">
        <image mode="scaleToFill" src="/resources/category/0-luxury.png" class="cat-icon" />
        <view class="cat-name">
            奢侈品
        </view>
    </view>
</view>
```

```js
//category.js
const app = getApp();
Page({
    data: {
        catImgList: [
            { id: 0, imgUrl: "/resources/category/0-luxury.png" },
            { id: 1, imgUrl: "/resources/category/1-new.png" },
            { id: 2, imgUrl: "/resources/category/2-skirt.png" },
            { id: 3, imgUrl: "/resources/category/3-trousers.png" },
            { id: 4, imgUrl: "/resources/category/4-shoes.png" },
            { id: 5, imgUrl: "/resources/category/5-boyfriend.png" },
            { id: 6, imgUrl: "/resources/category/6-suit.png" },
            { id: 7, imgUrl: "/resources/category/7-makeup.png" },
            { id: 8, imgUrl: "/resources/category/8-tshirt.png" },
            { id: 9, imgUrl: "/resources/category/9-acessories.png" },
            { id: 10, imgUrl: "/resources/category/10-bags.png" },
            { id: 11, imgUrl: "/resources/category/11-home.png" },
            { id: 12, imgUrl: "/resources/category/12-child.png" },
            { id: 13, imgUrl: "/resources/category/13-underwear.png" },
            { id: 14, imgUrl: "/resources/category/14-longuette.png" },
            { id: 15, imgUrl: "/resources/category/15-baby.png" },
        ],
        catList: [],
    },
    onLoad() {
        const self = this;
        // 请求新品分类
        my.httpRequest({
            url: app.serverUrl + '/cats',
            method: 'POST',
            header: { 'content-type': 'application/json' },
            dataType: 'json',
            success: function (res) {
                // 获取后端返回的数据
                console.log("catName:", res.data)
                var myData = res.data;
                if (myData.status === 200) {
                    var catList = myData.data;
                    catList.forEach((item, index) => {
                        item.imgUrl = self.data.catImgList[index].imgUrl
                    });
                    console.log("catList:", catList);
                    self.setData({
                        catList
                    })
                }

            }
        })
    },
});
```

#### 2021.09.10 fri 37week bj

##### 7-3 键盘回车触发confirm事件获取搜索框的值

- 通过网络请求拿到商品列表，解析数据在页面上渲染
- 每行显示两件商品，若单行只有一件商品，则布局左对齐
- 采用模板复用首页新品列表

##### 7-4 页面带参与debugger调试

```js
Page({
    data: {},
    onLoad(params) { // params 用于接收跳转传递的参数
        let { searcType, itemName } = params;
        console.log(params);
    },
});
```

##### 7-5 使用导航组件带参

```js
<navigator url="/pages/query/list/list?searchType=category&categoryId={{item.id}}&categoryName={{item.name}}">
      <image mode="scaleToFill" src="{{item.imgUrl}}" class="cat-icon" />
      <view class="cat-name">
          {{item.name}}
      </view>
  </navigator>
```

#### 2021.09.12 sun 37week bj

##### 7-6 根据不同参数发起网络请求查询商品列表

```js
// pages/query/list/list.js
const app = getApp();
Page({
    data: {},
    onLoad(params) {
        let self = this;
        let { catId, catName, searchType, itemName } = params;
        console.log("catId:", catId);
        console.log("catName:", catName);
        // 根据类型查询结果集
        if (searchType === 'cat') {
            my.httpRequest({
                url: app.serverUrl + '/items/searchByCat?catId=' + catId,
                method: 'POST',
                header: { 'content-type': 'application/json' },
                // data: {name:'jack', age: '18'},
                dataType: 'json',
                success: function (res) {
                    console.log(res);
                    // 获取后端返回的数据
                    var myData = res.data;
                    if (myData.status === 200) {
                        var itemList = myData.data;
                        console.log("itemList:", itemList);
                        // self.setData({
                        //     itemList
                        // })
                    }

                },
                complete: function (res) {
                    // console.log('最终执行的 complete:', res);
                }
            })
        } else if (searchType === 'words') {
            my.httpRequest({
                url: app.serverUrl + '/items/search',
                method: 'POST',
                header: { 'content-type': 'application/json' },
                data: { itemName },
                dataType: 'json',
                success: function (res) {
                    console.log(res);
                    // 获取后端返回的数据
                    var myData = res.data;
                    if (myData.status === 200) {
                        var itemList = myData.data;
                        console.log("itemList:", itemList);
                        // self.setData({
                        //     itemList
                        // })
                    }

                },
                complete: function (res) {
                    // console.log('最终执行的 complete:', res);
                }
            })
        }
    },
});
```

##### 7-7 使用交互api提高用户体验

```js
my.showNavigationBarLoading();
my.showLoading({
      content: '疯狂加载中'
});
complete: function (res) {
        my.hideNavigationBarLoading();
        my.hideLoading();
}
```

##### 7-8 查询结果文字动态数据绑定与显示

##### 7-9 使用模板实现商品列表代码公用

```xml
<!-- 商品列表的结果文字显示 -->
<view class="item-desc-bar">
    <view class="item-desc-title">
        {{titleName}}
    </view>
</view>
<!-- 导入模板 -->
<import src="/pages/template/itemList/itemList" />
<!-- 使用模板 is:模板名 data: 可以传入外部参数-->
<template is="itemList" data="{{newItemList:itemList}}"></template>
```

##### 7-10 httpRequest请求商品详情

- 查询商品的具体信息后，在页面上进行渲染
- 封面图多张，支持横向展示
- 详情内容根据后台 `json` 进行解析，解析后渲染成文字或图片

#### 2021.09.13 mon 38week bj

##### 7-11 开发商品详情页 - 封面图

```js
const app = getApp();

Page({
    data: {
        headerImagesArr: [],
    },
    onLoad(params) {
        let self = this;
        let { itemId } = params;
        // 获取上一个页面传过来的商品 id 主键
        // 请求接口，查询商品详情
        my.showNavigationBarLoading();
        my.showLoading({
            content: '疯狂加载中'
        });
        my.httpRequest({
            url: app.serverUrl + '/items/searchById?itemId=' + itemId,
            method: 'POST',
            header: { 'content-type': 'application/json' },
            dataType: 'json',
            success: function (res) {
                // 获取后端返回的数据
                var myData = res.data;
                // 获取封面图的数组字符串，并且转换为 json arr
                var headerImagesArr = JSON.parse(myData.data.headerImages);
                if (myData.status === 200) {
                    var item = myData.data;
                    console.log("item:", item);
                    self.setData({
                        headerImagesArr,
                    })
                }

            },
            complete: function (res) {
                my.hideNavigationBarLoading();
                my.hideLoading();
            }
        })
    },
});
```

##### 7-12 开发商品详情页 - 基本信息渲染 上

##### 7-13 开发商品详情页 - 基本信息渲染 下







































































































