#### 2021年01月08日 周五 第02周

(1)数据结构与算法：队列任务-代码操作

#### 2021年01月11日 周一 第03周

(1) React 源码深度解析： memo 组件的更新 & completeUnitWork的整体流程和意义。

- 根据是否中断调用不同的方法；
- 判断是否有兄弟节点来执行不同的操作；
- 完成节点之后赋值 effect 链；

(2)数据结构与算法：任务队列代码实操

```js
export default (tasks, n) => {
    // 声明一个变量记录最终任务的顺序
    let q = ''
    // 任务分类
    let Q = {}
    tasks.forEach(item => {
        if (Q[item]) {
            Q[item]++
        } else {
            Q[item]=1 
        }
    });
    while (1) {
        let keys = Object.keys(Q)
        if (!keys[0]) {
           break
        } 
        // n+1 为一组
        let tmp = []
        for (let i = 0; i <= n; i++) {
            let max = 0
            let key
            let pos
            // 从所有的任务中找到未处理数最大的优先安排
            keys.forEach((item, idx) => {
                if (Q[item] > max) {
                    max = Q[item]
                    key = item
                    pos = idx
                }
            })
            if (key) {
                tmp.push(key)
                keys.splice(pos, 1)
                Q[key]--
                if (Q[key] < 1) {
                    delete Q[key]
                }
            } else {
                break
            }
        }
        q+=tmp.join('').padEnd(n+1,'-')
    }
    // A--A--A-- 替换为 A--A--A
    q=q.replace(/-+$/g,'')
    return q.length
}
```

(3) 数据结构：排序链表 & 环形链表，重点是：如何手动创建一个链表的数据结构；知道链表如何排序；如何检测链表是闭环的。

排序链表：在O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例1：

```html
输入: 4->2->1->3
输出: 1->2->3->4
```

示例2：

```html
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

快速排序的本质：在遍历时选择一个基准元素，排序中的任何一个元素都可以作为基准元素，通常情况下选第一个就可以。把所有小于基准元素的元素，放在基准元素的左边；大于基准元素的元素，放在基准元素的右边；然后递归左边和右边的所有元素。

链表只会暴露一个头指针，所有的元素是不能直接访问到的，必须通过头指针不断地访问 next 对象，才能拿到具体的元素。设置两个指针p,q，都是指向头元素，p 指针左侧的元素是小于基准元素的，p 与 q 之间的元素是大于基准元素的。

#### 2021年01月12日 周二 第03周

(1) 高仿组件库:

> 参考网站：http://vikingship.xyz

- vikingship 是教学组件库，使用 React Hooks 和 typescript ；
- learning-typescript 为第二章 Typescript 入门源代码，只针对第二章；
- react-with-ts 为课程第三章，神奇的 React 源代码；

#### 2021年01月13日 周三 第03周

(1)数据结构与算法：链表的快速排序比堆排序使用的场景更多。

(2)数据结构与算法：环形链表-原理讲解

环形链表：给定一个链表，判断链表中是否有循环。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1` ，则在该链表中没有环。

示例1：

```
输入：head = [3,2,0,-4],pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

(3) 环形链表-代码实操

#### 2021年01月14日 周四 第03周

(1) 数据结构与算法：螺旋矩阵 & 旋转图像

给定一个包含 m x n 个元素的矩阵（m行，n列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例1：

```
输入：
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
输出：[1,2,3,6,9,8,7,4,5]
```

(2) 数据结构与算法：旋转图像

给定一个 n x n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例1：

```
给定 matrix = 
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
原地旋转输入矩阵，使其变为：
[
	[7,4,1],
	[8,5,2],
	[9,6,3]
]
```

示例2：

```
给定 matrix = 
[
 [5,1,9,11],
 [2,4,8,10],
 [13,3,6,7],
 [15,14,12,16]
]
原地旋转输入矩阵，使其变为：
[
	[15,13,2,5],
	[14,3,4,1],
	[12,6,8,9],
	[16,7,10,11]
]
```

#### 2021年01月15日 周五 第03周

(1)数据结构与算法：旋转图像-代码实操

```js
export default (arr) => {
  // 获取 n 的维度
  let vecor = arr.length;
  // 垂直翻转
  for (let i = 0, len = vecor / 2; i < len; i++) {
    for (let j = 0, tmp; j < vecor; j++) {
      tmp = arr[i][j];
      arr[i][j] = arr[vecor - i - 1][j];
      arr[vecor - i - 1][j] = tmp;
    }
  }
  // 对角线翻转
  for (let i = 0; i < vecor; i++) {
    for (let j = 0, tmp; j < i; j++) {
      let tmp = arr[i][j];
      arr[i][j] = arr[j][i];
      arr[j][i] = tmp;
    }
  }
  return arr;
};
```

(2)数据结构与算法：对称二叉树-原理讲解，二叉树是出现频率很高，难度最大的数据结构。二叉树的特性之一是一个节点只有两个子节点，左节点和右节点。

给定一个二叉树，检查它是否是镜像对称。例如，二叉树 `[1,2,2,3,4,4,3] ` 是对称的。

```
	    1
	  /	 \
   2 		2
 /  \   / \
3   4  4   3
```

但是下面这个 `[1,2,2,null,3,null,3] ` 则不是镜像对称的：

```
		1
	/		\
	2		2
	\ 	\
	3 	3
```

(3) 数据结构与算法：对称二叉树-代码实操

```js
// 构造二叉树数据结构
// 二叉树的节点
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}
// 声明一个二叉树
class Tree {
  constructor(data) {
    // 临时存储所有节点，方便寻找父子节点
    let nodeList = [];
    // 顶节点
    let root;
    for (let i = 0, len = data.length; i < len; i++) {
      let node = new Node(data[i]);
      nodeList.push(node);
      if (i > 0) {
        // 计算当前节点属于哪一层
        let n = Math.floor(Math.sqrt(i + 1));
        // 记录当前层的起始点
        let q = Math.pow(2, n) - 1;
        // 记录上一层的起始点
        let p = Math.pow(2, n - 1) - 1;
        // 找到当前节点的父节点
        let parent = nodeList[p + Math.floor((i - q) / 2)];
        // 将当前节点和上一层的父节点做关联
        if (parent.left) {
          parent.right = node;
        } else {
          parent.left = node;
        }
      }
    }
    root = nodeList.shift();
    nodeList.length = 0;
    return root;
  }
  // 判断是否对称的静态方法
  static isSymmetry(root) {
    if (!root) {
      return true;
    }
    let walk = (left, right) => {
      if (!left && !right) {
        return true;
      }
      if ((left && !right) || (!left && right) || left.val !== right.val) {
        return false;
      }
      return walk(left.left, right.right) && walk(left.right, right.left);
    };
    return walk(root.left, root.right);
  }
}

export default Tree;
export { Node };
```

#### 2021年01月16日 周六 第03周

(1)数据结构与算法：验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例1：

```
输入：
 		2
 	/  \
 	1 	3
输出：true
```

(2)数据结构与算法：验证二叉搜索树-代码实操

```js
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}

class Tree {
  constructor(data) {
    let root = new Node(data.shift());
    //   遍历所有的数据，逐渐插入到当前这棵搜索树上
    data.forEach((item) => {
      this.insert(root, item);
    });
    return root;
  }
  insert(node, data) {
    if (node.val > data) {
      if (node.left === undefined) {
        node.left = new Node(data);
      } else {
        this.insert(node.left, data);
      }
    } else {
      if (node.right === undefined) {
        node.right = new Node(data);
      } else {
        this.insert(node.right, data);
      }
    }
  }
  static walk(root) {
    if (!root.left && !root.right) {
      return true;
    } else if (
      (root.left && root.val < root.left.val) ||
      (root.right && root.val > root.right.val)
    ) {
      return false;
    } else {
      return Tree.walk(root.left) && Tree.walk(root.right);
    }
  }
}

export default Tree;
export { Node };
```

(3)数据结构与算法：堆排序-原理讲解，根据字符串出现频率排序（排序） & 超级丑数（查找）

堆更靠近二叉树，而非堆栈；应用场景：利用堆的数据结构去排序和查找。

基本概念：

- 堆必须是完全二叉树（n-1层是满二叉树，都有左右节点）；

- 任一节点的值是其子树所有节点的最大值或最小值。

例如：

```
		  	56(最大堆)
			 /   \
		 19     40
    / \     /
   18  9   3
```


```
		  	 5(最小堆)
			 /   \
		 16     30
    / \     /
   49  18  38
```

#### 2021年01月17日 周日 第03周

do nothing.

#### 2021年01月18日 周一 第04周

(1)数据结构与算法：堆排序-代码演示

```js
class Heap {
  constructor(data) {
    this.data = data;
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      for (let j = 0; j < n; j++) {
        Heap.swap(iArr, 0, n - 1 - j);
        Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
      }
      return iArr;
    }
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}

export default Heap;
```

(2)数据结构与算法：堆排序-代码演示

根据字符出现频率排序，给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例1：

```
输入："tree"
输出："eert"
解释：'e' 出现两次，'r'和't'都只出现一次。因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

第一步：统计；第二步：排序；第三步：输出；

```js
class Heap {
  constructor(str) {
    let map = new Map();
    str.split("").forEach((item) => {
      if (map.has(item)) {
        map.set(item, map.get(item) + 1);
      } else {
        map.set(item, 1);
      }
    });
    this.map = map;
    this.data = Array.from(map.values());
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      for (let j = 0; j < n; j++) {
        Heap.swap(iArr, 0, n - 1 - j);
        Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
      }
      return iArr;
    }
  }
  toString() {
    let arr = this.sort();
    let str = [];
    while (arr.length) {
      let top = arr.pop();
      for (let [k, v] of this.map) {
        if (v === top) {
          str.push(k.repeat(v));
          this.map.delete(k);
          break;
        }
      }
    }
    return str.join("");
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}

export default Heap;
```

(3)数据结构与算法：超级丑数，丑数，质因数，质数。

编写一段程序来查找第 n 个超级丑数。超级丑数是指其所有质因数都是长度为 k 的质数列表 `primes` 中的正整数。

示例：

```
输入：n=12,primes=[2,7,13,19]
输出：32
解释：给定长度为 4 的质数列表 primes=[2,7,13,19],前12个超级丑数列表为：[1,2,4,7,8,13,14,16,19,26,28,32]。
```

解题思路：

- 求解任意整数的质因数
- 质因数是否在指定质因数范围内
- 是否达到指定个数 n

#### 2021年01月20日 周三 第04周

(1) 数据结构与算法: 超级丑数-代码演示(数组查找)

```js
class Ugly {
  constructor(n, primes) {
    this.n = n;
    this.primes = primes;
  }
  // 计算超级丑数
  getAll() {
    // 超级丑数列表
    let res = [1];
    let i = 2;
    let primes = this.primes;
    while (res.length < this.n) {
      let arr = Ugly.getPrimes(i);
      let k = 0;
      let l = arr.length;
      for (; k < l; k++) {
        if (!primes.find((item) => item === arr[k])) {
          break;
        }
      }
      // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
      if (k === l) {
        if (l === 0) {
          if (primes.find((item) => item === i)) {
            res.push(i);
          }
        } else {
          res.push(i);
        }
      }
      i++;
    }
    return res[this.n - 1];
  }
  // 计算指定正整数n的质因数
  static getPrimes(n) {
    //
    let prime = (n) => {
      // 存储所有的质因数
      let arr = [];
      for (let i = 2; i < n / 2 + 1; i++) {
        if (n % i === 0 && !prime(i).length) {
          arr.push(i);
        }
      }
      return arr;
    };
    return prime(n);
  }
}

export default Ugly;
```

(2) 数据结构与算法: 超级丑数-代码演示(堆查找)

```js
class Ugly {
  constructor(n, primes) {
    this.n = n;
    this.primes = new Heap(primes);
  }
  // 计算超级丑数
  getAll() {
    // 超级丑数列表
    let res = [1];
    let i = 2;
    let primes = this.primes;
    while (res.length < this.n) {
      let arr = Ugly.getPrimes(i);
      let k = 0;
      let l = arr.length;
      for (; k < l; k++) {
        if (!primes.find(arr[k])) {
          break;
        }
      }
      // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
      if (k === l) {
        if (l === 0) {
          if (primes.find(i)) {
            res.push(i);
          }
        } else {
          res.push(i);
        }
      }
      i++;
    }
    return res[this.n - 1];
  }
  // 计算指定正整数n的质因数
  static getPrimes(n) {
    //
    let prime = (n) => {
      // 存储所有的质因数
      let arr = [];
      for (let i = 2; i < n / 2 + 1; i++) {
        if (n % i === 0 && !prime(i).length) {
          arr.push(i);
        }
      }
      return arr;
    };
    return prime(n);
  }
}

class Heap {
  constructor(arr) {
    this.data = arr;
    this.max = arr.length;
    this.sort();
  }
  find(val, i = 0) {
    let arr = this.data;
    if (val > arr[i] || i > this.max) {
      return false;
    } else if (val === arr[i]) {
      return val;
    } else {
      return this.find(val, i * 2 + 1) || this.find(val, i * 2 + 2);
    }
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      return iArr;
    }
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}
export default Ugly;
export { Heap };
```

(3)进阶算法：贪心算法-买卖股票的最佳时机&柠檬水找零

(4进阶算法: 贪心算法（又称贪婪算法），是指在对**问题求解**时，总是做出在当前看来是最好的的选择。也就是说，不从整理最优上加以考虑，他所做出的是在某种意义上的**局部最优解**。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须是具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

**买卖股票的最佳时机 II:** 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1：

```
输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
随后，在第4天（股票价格=3）的时候买入，在第5天（股票价格=6）的时候卖出，这笔交易所能获得利润 = 6-3=3。
```

示例2：

```
输入：[1,2,3,4,5]
输出：4
解释：在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例3：

```
输入：[7,6,4,3,1]
输出：0
解释：在这种情况下，没有完成交易，所以最大利润为0。
```

贪心算法：

**问题：最大利润**

**策略1**：从最低点买入，在最高点卖出（追求单次利益）

**策略2**：从低点买入，只要可以赚钱就卖出；不断买卖（追求多次利益，单次利益不够）

**策略3**：从低点买入，到价格高点卖出，不断买卖（在保证单次利益的基础上，实现多次交易）

#### 2021年01月21日 周四 第04周

(1) 数据结构与算法：买卖股票最佳时机-代码实操

```js
export default (prices) => {
  // 用来保存利润
  let count = 0;
  for (let i = 0, len = prices.length; i < len; i++) {
    for (let j = i; j < len - 1; j++) {
      if (prices[j + 1] > prices[j]) {
        count += prices[j + 1] - prices[j];
        i = j;
      } else {
        i = j;
        break;
      }
    }
  }
  return count;
};
```

(2) 数据结构与算法：柠檬水找零-原理讲解，在柠檬水摊位上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你支付5美元、10美元或20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付5美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true，否则返回 false。

示例1：

```
输入：[5,5,5,10,20]
输出：true
解释：
前3位顾客那里，我们按顺序收取3张5美元的钞票。
第4位顾客那里，我们收取一张10美元的钞票，并返回5美元。
第5位顾客那里，我们找还一张10美元的钞票和一张5美元的钞票。
由于所有客户都得到了正确的找零，所以我们会输出 true。
```

问题：找零钱

策略1：给钱找零，不区分金额直到找到足够的零钱（追求单词找零）

策略2：给钱找零，优先给金额大的零钱，尽量把零钱放在手里（追求多次找零）

示例2：

```
输入：[5,5,10]
输出：true
```

示例3：

```
输入：[10,10]
输出：false
```

示例4：

```
输入：[5,5,10,10,20]
输出：false
```

(3)数据结构与算法：柠檬水找零-代码演示

```js
export default (input) => {
  // 表示自己的钱箱（用于存储零钱）
  let hand = [];
  // 判断是否有顾客还在
  while (input.length) {
    // 取出当前排在最前面顾客的钱
    let money = input.shift();
    // 这种情况不需要找零钱
    if (money === 5) {
      hand.push(money);
    } else {
      // 手里的零钱要降序排列，也就是说最大的面值的钱放在最前面
      hand.sort((a, b) => b - a);
      // 顾客的钱减去饮料的钱就是需要找给顾客的零钱
      let change = money - 5;
      for (let i = 0, len = hand.length; i < len; i++) {
        if (hand[i] <= change) {
          change -= hand[i];
          hand.splice(i, 1);
          // 删除了元素，数组的长度发生了变化，要维持刚才的i不变
          i--;
        }
        if (change === 0) {
          break;
        }
      }
      // 没有足够的钱找给顾客
      if (change !== 0) {
        return false;
      } else {
        // 顾客的钱存起来
        hand.push(money);
      }
    }
  }
  return true;
};
```

#### 2021年01月22日 周五 第04周

(1) 数据结构与算法：进阶算法-动态规划之不同路径II 和 K 站中转内最便宜的航班

动态规划三个重要概念：动态转移方程、最优子结构、边界

不同路径II：一个机器人位于一个 m x n 网格的左上角（起点在下图中标记的 Start）。机器人每次只能向下或向右移动一步。机器人试图到达网格的右下角（在下图中标记为 Finish）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

| Start |      |      |      |      |      |        |
| :---: | ---- | ---- | ---- | ---- | ---- | :----: |
|       |      |      |      |      |      |        |
|       |      |      |      |      |      | Finish |

网格中的障碍物和空位置分别用1和0来表示。

示例1：

```
输入：
[
 [0,0,0],
 [0,1,0],
 [0,0,0]
]
输出：2
解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有2条不同的路径：
1.向右 -> 向右 -> 向下 -> 向下
2.向下 -> 向下 -> 向右 -> 向右
```

mxn：m行n列的状态方程是 F(mxn) = F(m-1xn) + F(mxn-1)

(2)不同路径II-代码实操：

```js
export default (arr, m, n) => {
  let dp = (m, n) => {
    // m=2,n=2 的边界
    if (m === 2 && n === 2) {
      return arr[1][1] || arr[1][0] + arr[0][1] === 2
        ? 0
        : arr[1][0] === 1 || arr[0][1] === 1
        ? 1
        : 2;
    } else if (m < 2 || n < 2) {
      if (m < 2) {
        // 单行有1就返回0，没有1返回1
        return arr[m - 1].includes(1) ? 0 : 1;
      } else {
        // 单列不能有障碍物(1)有它返回0，没有1返回1
        for (let i = 0; i < m; i++) {
          if (arr[i][0] === 1) {
            return 0;
          }
        }
        return 1;
      }
    } else {
      return dp(m - 1, n) + dp(m, n - 1);
    }
  };
  return dp(m, n);
};
```

(3) K站中转内最便宜的航班：有n个城市通过m个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和 目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。

如果没有这样的路线，则输出 -1。

示例1：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=1
输出：200
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

示例2：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=0
输出：500
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

动态转移方程：F(src,dst,k) = Min(F(src,dst-1,k-1) + F(dst-1,dst,1))

(4) k站中转站-代码实操

```js
export default (src, dst, k) => {
  // 对n个城市m个航班做飞行说明
  let fights = [
    [0, 1, 100],
    [1, 2, 100],
    [0, 2, 500],
  ];
  let cheap = (src, dst, k) => {
    // 找到 dst 的前一站
    let prev = fights.filter((item) => item[1] === dst);
    let min = Math.min.apply(
      null,
      prev.map((item) => {
        // 从 dst 往前找，找到了起始城市
        if (item[0] === src && k > -1) {
          return item[2];
        } else if (k === 0 && item[0] !== src) {
          return Number.MAX_SAFE_INTEGER;
        } else {
          return item[2] + cheap(src, item[0], k - 1);
        }
      })
    );
    return min;
  };
  return cheap(src, dst, k) || -1;
};
```

(5) 课程总结：

基础算法：

| 常见类型：字符串、数组、正则 |
| ---------------------------- |
| 常见题型：查重、排序、递归   |
| 知识点：基础API、常用技巧    |

数据结构与算法：

| 常见结构：栈、队列、链表、矩阵、二叉树、堆 |
| ------------------------------------------ |
| 常见题型：结构实现、查找、排序、拓展应用   |
| 知识点：原理、实现、实战思想               |

(6) 前端人的危机如何破解选

选择和被选择都是一种能力。可以选择是一种资本，可以被选择是一种资历，无论是哪种都可以成就一番事业。不然危机会大一些、遗憾也会随之而来。破除危机：积累可以选择的资本 or 增加被选择的资历。

会工作 & 会学习：入门级 - 如何学习？如何面试？如何提升？风险最高。

入门级：

如何学习？人群：学生、转行、自学；目标：学习基础知识；途径：网络博客、视频课程、培训班；方法：临摹；自测：是不是能够独立解决问题；心态：脚踏实地、切莫投机取巧。

如何面试？目标：工作机会；准备：基础知识+实战经验；技巧：基础+能力+潜力；自测：刷题+面经+技术分析。基础知识好不等于要懂所有的知识；每个人都有自己的知识盲区。

如何提升？目标：提升解决问题的能力；方法：多看、多听、多做、多思考，不放过任何一个机会；忌讳：自负、多问题、懒散；自测：是否能独立解决问题。

中高级：如何学习？如何成长？如何晋升？

如何学习？背景：学的很累；原则：先少后多、先精后广；方法：平衡学习、工作、生活的时间，多利用社区的力量；

如何成长？定义：技术、做事；方法：自驱动、敢于挑战、承担责任；自测：技术架构、独立做事、彼此成就。

如何晋升？目标：加薪、晋级；方法：少说、多做、任劳任怨、有效沟通、拒绝平庸、全面发展；心态：先付出再回报、个人服从集体、学会定位和补位、足够耐心。

(7) TS+React打造组件库：

(8) WebRTC学习：

特点：Google开源、跨平台、用于浏览器、实时传输、音视频引擎；

应用领域：音视频会议在线教育、照相机、音乐播放器、共享远程桌面、录制、即时通讯工具、P2P网络加速、文件传输工具、游戏、实时人脸识别；

#### 2021年01月23日 周六 04周

(1) WebRTC学习：学习收获，WebRTC API 的使用；WebRTC 工作原理；信令服务器的设计与搭建；实现1:1实时互动直播系统。

(2) WebRTC 入门与实战：WebRTC 介绍

WebRTC 概述：

- 音视频处理+即时通讯的开源库；
- 2010年 Google 将其开源；
- 它是一个非常优秀的多媒体框架，跨平台；

WebRTC应用：

- 音视频实时互动；游戏、即时通讯、文件传输等等；它是一个百宝箱，传输、音视频处理（回音消除、降噪等）

能学到什么：

- 音视频设备访问与管理；音视频数据的采集；数据的传输与实时互动；WebRTC 的工作机制；

(3) TS+React组件库：安装和初试TypeScript

```bash
# 全局安装
npm install -g typescript@3.7.2
# 查看版本号
tsc -v 
```

（4）TS+React组件库：基础类型， undefined 和 null 是所有类型的子类型

（5）TS+React组件库：any 类型和联合类型，尽可能慎用，

```typescript
//any 类
let notSure: any = 4
notSure = 'maybe it is a string'
notSure = true
notSure.myName
notSure.getName()
```

```typescript
// union 类型
let numberOrString: number | string = 234
numberOrString = 'abc'
```

（6）TS+React组件库：Array 和 Tuple(元组)

```typescript
// Array
let arrayOfNumber: number[] = [1, 2, 3, 4]
arrayOfNumber.push(5)
// Tuple 元组是限定了数据类型的一种数组，必须所有类型都有
let user: [string, number] = ['viking', 1]
```

