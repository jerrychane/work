<!--
 * @Author: jerrychane
 * @LastEditors: jerrychane
 * @Date: 2021-09-23 23:06:09
 * @LastEditTime: 2021-09-24 08:39:15
-->
真正理解原型和原型链的关系，最好的方法莫过于整理一张流程图。绘制流程图的好处在于绘制的过程中，即检验自己对这个知识点的掌握程度，同时在绘制过程中加深对这个知识点的印象，理解更透彻。
为了更清晰地了解原型链的走向，可以先创建三个构造函数，建立 `多重继承` 关系，分别为 `Person` 、 `ChinaPerson` 、 `ProvincePerson` ，它们之间的继承关系为: `ProvincePerson` 继承 `ChinaPerson` ， `ChinaPerson` 又继承 `Person` 。
 

#### 一. 多重继承的代码

先贴上代码，每个子构造函数会在继承父级的基础上，分别在构造函数里面和原型里面，添加自己的自定义的属性和方法；另外在 `Person` 原型上写上和构造函数里同名的属性和方法，用来验证同名方法时，构造函数里的方法和原型上的方法哪个优先执行；在 `ProvincePerson` 上会重写从父级继承的方法，侧面大概展示一下面向对象的 `多态` 特性。

```js
/**
 * JavaScript多级继承和多态、原型和原型链
 **/
// 1.1 构造函数：Person(人)
function Person(name) {
    this.name = name ? name : "human";
    this.methodPerson = function() {
        console.log('Person构造函数里的方法methodPerson:' + this.name);
    }
    console.log("=================== Person 构造函数 初始化 ===================");
}
// 给 Person 原型上添加属性和方法
Person.prototype.age = 18;
Person.prototype.run = function() {
    console.log('Person 原型上的方法 run:' + this.name + ', age:' + this.age);
}
// 1.2 构造函数：ChinaPerson(中国人),继承于 Person
function ChinaPerson(name, skin) {
    Person.call(this, name); // 调用父级 Person 构造函数
    this.skin = skin ? skin : 'yellow';
    this.methodChinaPerson = function() {
        console.log('ChinaPerson 构造函数里的方法 methodChinaPerson skin:' + this.skin + ', tag:' + this.name);
    }
    console.log("=================== ChinaPerson 构造函数 初始化 ===================");
}
// 设置 ChinaPerson 原型指向 Person 原型，相当于 ChinaPerson 继承 Person
ChinaPerson.prototype = Object.create(Person.prototype);
// 设置新原型的构造函数指向自身
ChinaPerson.prototype.constructor = ChinaPerson;
// 给 ChinaPerson 的原型添加自定义的属性和方法
ChinaPerson.prototype.hero = 'Hua Mu Lan';
ChinaPerson.prototype.write = function() {
    console.log('ChinaPerson 原型里面的方法 write:唧唧复唧唧，木兰当户织! is who ?' + this.hero + ', tag:' + this.name + ', skin:' + this.skin);
}
// 1.3 构造函数: ProvincePerson(省城人)，继承 ChinaPerson
function ProvincePerson(name, skin, count) {
    ChinaPerson.call(this, name, skin);
    this.count = count ? count : 800;
    this.methodProvincePerson = function() {
        console.log('ProvincePerson 构造函数里面的方法 methodProvincePerson ---> count:' + this.count + 'w，skin:' + this.skin + 'tag:' + this.name);
    }
    // 重写从父级继承下来的方法 
    this.methodChinaPerson = function() {
        console.log('ProvincePerson 构造函数里重写父级方法 methodChinaPerson');
    }
    console.log("=================== ProvincePerson 构造函数 初始化 ===================");
}
// 设置 ProvincePerson 的原型执行 ChinaPerson 的原型，相当于 ProvincePerson 继承 ChinaPerson
ProvincePerson.prototype = ChinaPerson.prototype;
// 设置 ProvincePerson 的原型的构造函数指向自身
ProvincePerson.prototype.constructor = ProvincePerson;
// 给 ProvincePerson 的原型上添加自定义的属性和方法
ProvincePerson.prototype.feature = '武汉热干面';
ProvincePerson.prototype.eat = function() {
    console.log('ProvincePerson 原型里面的方法 eat ---> tag:' + this.name + ', like eat:' + this.feature + ', hero:' + this.hero + ', skin:' + this.skin);
}
// 重写从父级原型继承下来的方法
ProvincePerson.prototype.write = function() {
    console.log('ProvincePerson 原型里重写从父级原型继承的 write 方法!');
}
```

#### 二. 绘制原型链流程图

结合以上的代码，绘制构造函数原型链的关系，如下图：


#### 三. 测试代码验证
